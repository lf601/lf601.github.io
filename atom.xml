<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>流风小屋</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2023-07-29T05:52:30.884Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>流风花水</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2023/07/29/hello-world/"/>
    <id>http://example.com/2023/07/29/hello-world/</id>
    <published>2023-07-29T05:52:30.884Z</published>
    <updated>2023-07-29T05:52:30.884Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>oslab5_report</title>
    <link href="http://example.com/2023/07/08/oslab5-report/"/>
    <id>http://example.com/2023/07/08/oslab5-report/</id>
    <published>2023-07-08T06:45:38.000Z</published>
    <updated>2023-07-29T05:52:30.886Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="lab5实验报告"><a href="#lab5实验报告" class="headerlink" title="lab5实验报告"></a>lab5实验报告</h2><h3 id="1-准备工程"><a href="#1-准备工程" class="headerlink" title="1.准备工程"></a>1.准备工程</h3><ul><li>此次试验根据lab4所实现代码进行</li><li>需要修改 <code>vmlinux.lds.S</code>，将用户态程序 <code>uapp</code> 加载至 <code>.data</code> 段。按如下修改：</li></ul><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs haskell">.<span class="hljs-class"><span class="hljs-keyword">data</span> : <span class="hljs-type">ALIGN</span>(0<span class="hljs-title">x1000</span>)&#123;</span><br><span class="hljs-class">        <span class="hljs-title">_sdata</span> = .;</span><br><span class="hljs-class"></span><br><span class="hljs-class">        *(.<span class="hljs-title">sdata</span> .<span class="hljs-title">sdata</span>*)</span><br><span class="hljs-class">        *(.<span class="hljs-title">data</span> .<span class="hljs-title">data</span>.*)</span><br><span class="hljs-class"></span><br><span class="hljs-class">        <span class="hljs-title">_edata</span> = .;</span><br><span class="hljs-class"></span><br><span class="hljs-class">        . = <span class="hljs-type">ALIGN(0x1000)</span>;</span><br><span class="hljs-class">        <span class="hljs-title">uapp_start</span> = .;</span><br><span class="hljs-class">        *(.<span class="hljs-title">uapp</span> .<span class="hljs-title">uapp</span>*)</span><br><span class="hljs-class">        <span class="hljs-title">uapp_end</span> = .;</span><br><span class="hljs-class">        . = <span class="hljs-type">ALIGN(0x1000)</span>;</span><br><span class="hljs-class"></span><br><span class="hljs-class">    &#125; &gt;ramv <span class="hljs-type">AT</span>&gt;ram</span><br></code></pre></td></tr></table></figure><ul><li>需要修改 <code>defs.h</code>，在 <code>defs.h</code> <code>添加</code> 如下内容：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> USER_START (0x0000000000000000) <span class="hljs-comment">// user space start virtual address</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> USER_END   (0x0000004000000000) <span class="hljs-comment">// user space end virtual address</span></span><br></code></pre></td></tr></table></figure><ul><li>从 <code>repo</code> 同步以下文件夹: <code>user</code>， <code>Makefile</code>。并按照以下步骤将这些文件正确放置。</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs stylus">.<br>├── arch<br>│   └── riscv<br>│       └── Makefile<br>└── user<br>    ├── Makefile<br>    ├── getpid<span class="hljs-selector-class">.c</span><br>    ├── link<span class="hljs-selector-class">.lds</span><br>    ├── printf<span class="hljs-selector-class">.c</span><br>    ├── start<span class="hljs-selector-class">.S</span><br>    ├── stddef<span class="hljs-selector-class">.h</span><br>    ├── stdio<span class="hljs-selector-class">.h</span><br>    ├── syscall<span class="hljs-selector-class">.h</span><br>    └── uapp.S<br></code></pre></td></tr></table></figure><ul><li>修改<strong>根目录</strong>下的 Makefile, 将 <code>user</code> 纳入工程管理。</li><li>在根目录下 <code>make</code> 会生成 <code>user/uapp.o</code> <code>user/uapp.elf</code> <code>user/uapp.bin</code>。 通过 <code>objdump</code> 我们可以看到 uapp 使用 ecall 来调用 SYSCALL (在 U-Mode 下使用 ecall 会触发environment-call-from-U-mode异常)。从而将控制权交给处在 S-Mode 的 OS， 由内核来处理相关异常。</li></ul><h3 id="2-创建用户态进程"><a href="#2-创建用户态进程" class="headerlink" title="2.创建用户态进程"></a>2.创建用户态进程</h3><ul><li>本次实验只需要创建 4 个用户态进程，修改 <code>proc.h</code> 中的 <code>NR_TASKS</code> 为5。</li><li>由于创建用户态进程要对 <code>sepc</code> <code>sstatus</code> <code>sscratch</code> 做设置，我们将其加入 <code>thread_struct</code> 中。</li><li>由于多个用户态进程需要保证相对隔离，因此不可以共用页表。我们为每个用户态进程都创建一个页表。修改 <code>task_struct</code> 如下。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// proc.h </span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>* <span class="hljs-type">pagetable_t</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread_struct</span> &#123;</span><br>    <span class="hljs-type">uint64_t</span> ra;<br>    <span class="hljs-type">uint64_t</span> sp;                     <br>    <span class="hljs-type">uint64_t</span> s[<span class="hljs-number">12</span>];<br><br>    <span class="hljs-type">uint64_t</span> sepc, sstatus, sscratch; <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread_info</span>* <span class="hljs-title">thread_info</span>;</span><br>    <span class="hljs-type">uint64_t</span> state;<br>    <span class="hljs-type">uint64_t</span> counter;<br>    <span class="hljs-type">uint64_t</span> priority;<br>    <span class="hljs-type">uint64_t</span> pid;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread_struct</span> <span class="hljs-title">thread</span>;</span><br><br>    <span class="hljs-type">pagetable_t</span> pgd;<br>    uint64 kernel_sp,user_sp;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>修改task_init<ul><li>对每个用户态进程，其拥有两个 stack： <code>U-Mode Stack</code> 以及 <code>S-Mode Stack</code>， 其中 <code>S-Mode Stack</code> 在 <code>lab3</code> 中我们已经设置好了。我们可以通过 <code>kalloc</code> 接口申请一个空的页面来作为 <code>U-Mode Stack</code>。</li><li>为每个用户态进程创建自己的页表 并将 <code>uapp</code> 所在页面，以及 <code>U-Mode Stack</code> 做相应的映射，同时为了避免 <code>U-Mode</code> 和 <code>S-Mode</code> 切换的时候切换页表，我们也将内核页表 （ <code>swapper_pg_dir</code> ） 复制到每个进程的页表中。</li><li>对每个用户态进程我们需要将 <code>sepc</code> 修改为 <code>USER_START</code>， 设置 <code>sstatus</code> 中的 <code>SPP</code> （ 使得 sret 返回至 U-Mode ）， <code>SPIE</code> （ sret 之后开启中断 ）， <code>SUM</code> （ S-Mode 可以访问 User 页面 ）， <code>sscratch</code> 设置为 <code>U-Mode</code> 的 sp，其值为 <code>USER_END</code> （即  <code>U-Mode Stack</code> 被放置在 <code>user space</code> 的最后一个页面）。</li></ul></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">task_init</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">//删去了前面实验的代码,只保留了本次实验新增代码</span><br>    <span class="hljs-keyword">for</span>(;i&lt;NR_TASKS;i++)<br>    &#123;<br>        <span class="hljs-comment">//通过kalloc接口申请一个空页面作为U-Mode Stack</span><br>        task[i]-&gt;kernel_sp = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)(task[i])+PGSIZE;<br>        task[i]-&gt;user_sp = kalloc();<br><br>        <span class="hljs-comment">//将内核页表映射到每个进程的pgtbl中</span><br>        <span class="hljs-type">pagetable_t</span> pgtbl = (<span class="hljs-type">pagetable_t</span>)kalloc();<br>        <span class="hljs-built_in">memcpy</span>(pgtbl,swapper_pg_dir,PGSIZE);<br><br>        <span class="hljs-comment">//映射uapp所在页面，权限设置为U|X|W|R|V</span><br>        uint64 va = USER_START;<br>        uint64 pa = (uint64)uapp_start-PA2VA_OFFSET;<br>        create_mapping(pgtbl,va,pa,(uint64)(uapp_end)-(uint64)(uapp_start),<span class="hljs-number">31</span>);<br><br>        <span class="hljs-comment">//映射U-Mode Stack，权限设置为 U|-|W|R|V</span><br>        va = USER_END-PGSIZE;<br>        pa = task[i]-&gt;user_sp-PA2VA_OFFSET;<br>        create_mapping(pgtbl,va,pa,PGSIZE,<span class="hljs-number">23</span>);<br><br>        uint64 satp = csr_read(satp);<br>        satp = (satp&gt;&gt;<span class="hljs-number">44</span>)&lt;&lt;<span class="hljs-number">44</span>;<br>        satp |= ((uint64)pgtbl-PA2VA_OFFSET)&gt;&gt;<span class="hljs-number">12</span>;<br>        task[i]-&gt;pgd = satp;<br>        <span class="hljs-comment">//设置sepc,sstatus,sscratch</span><br>        task[i]-&gt;thread.sepc = USER_START;<br>        task[i]-&gt;thread.sscratch = USER_END;<br>        uint64 sstatus = csr_read(sstatus);<br>        sstatus &amp;= ~(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">8</span>); <span class="hljs-comment">// SPP置为0</span><br>        sstatus |= <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">5</span>;    <span class="hljs-comment">// SPIE置为1</span><br>        sstatus |= <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">18</span>;   <span class="hljs-comment">// sscratch置为1</span><br>        task[i]-&gt;thread.sstatus = sstatus;<br>    &#125;<br><br>    <span class="hljs-type">const</span> uint64 OffsetOfThreadInTask = offsetof(<span class="hljs-keyword">struct</span> task_struct, thread);<br>    <span class="hljs-type">const</span> uint64 OffsetOfRaInTask = OffsetOfThreadInTask+offsetof(<span class="hljs-keyword">struct</span> thread_struct,ra);<br>    <span class="hljs-type">const</span> uint64 OffsetOfSpInTask = OffsetOfThreadInTask+offsetof(<span class="hljs-keyword">struct</span> thread_struct, sp);<br>    <span class="hljs-type">const</span> uint64 OffsetOfSInTask = OffsetOfThreadInTask+offsetof(<span class="hljs-keyword">struct</span> thread_struct, s);<br>    <span class="hljs-type">const</span> uint64 OffsetOfSepcInTask = OffsetOfThreadInTask+offsetof(<span class="hljs-keyword">struct</span> thread_struct, sepc);<br><br>    <span class="hljs-comment">//printk(&quot;OffsetOfRaInTask = %d\n&quot;, OffsetOfRaInTask);</span><br>    <span class="hljs-comment">//printk(&quot;OffsetOfSpInTask = %d\n&quot;, OffsetOfSpInTask);</span><br>    <span class="hljs-comment">//printk(&quot;OffsetOfSInTask = %d\n&quot;, OffsetOfSInTask);</span><br>    <span class="hljs-comment">//printk(&quot;OffsetOfSepcInTask = %d\n&quot;,OffsetOfSepcInTask);</span><br>    <br>    printk(<span class="hljs-string">&quot;...proc_init done!\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>修改 __switch_to， 需要加入 保存&#x2F;恢复 <code>sepc</code> <code>sstatus</code> <code>sscratch</code> 以及 切换页表的逻辑。</li></ul><p>添加了以下代码</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">addi </span><span class="hljs-built_in">t0</span>,<span class="hljs-built_in">a0</span>,<span class="hljs-number">152</span><br>csrr <span class="hljs-built_in">t1</span>,sepc<br>sd <span class="hljs-built_in">t1</span>,<span class="hljs-number">0</span>(<span class="hljs-built_in">t0</span>)<br>csrr <span class="hljs-built_in">t1</span>,sstatus<br>sd <span class="hljs-built_in">t1</span>,<span class="hljs-number">8</span>(<span class="hljs-built_in">t0</span>)<br>csrr <span class="hljs-built_in">t1</span>,sscratch<br>sd <span class="hljs-built_in">t1</span>,<span class="hljs-number">16</span>(<span class="hljs-built_in">t0</span>)<br>csrr <span class="hljs-built_in">t1</span>,satp<br>sd <span class="hljs-built_in">t1</span>,<span class="hljs-number">24</span>(<span class="hljs-built_in">t0</span>)<br><br><span class="hljs-keyword">addi </span><span class="hljs-built_in">t0</span>,<span class="hljs-built_in">a1</span>,<span class="hljs-number">152</span><br>ld <span class="hljs-built_in">t1</span>,<span class="hljs-number">0</span>(<span class="hljs-built_in">t0</span>)<br>csrw sepc,<span class="hljs-built_in">t1</span><br>ld <span class="hljs-built_in">t1</span>,<span class="hljs-number">8</span>(<span class="hljs-built_in">t0</span>)<br>csrw sstatus,<span class="hljs-built_in">t1</span><br>ld <span class="hljs-built_in">t1</span>,<span class="hljs-number">16</span>(<span class="hljs-built_in">t0</span>)<br>csrw sscratch,<span class="hljs-built_in">t1</span><br>ld <span class="hljs-built_in">t1</span>,<span class="hljs-number">24</span>(<span class="hljs-built_in">t0</span>)<br>csrw satp, <span class="hljs-built_in">t1</span><br></code></pre></td></tr></table></figure><h3 id="3-修改中断入口-x2F-返回逻辑-trap-以及中断处理函数-（-trap-handler-）"><a href="#3-修改中断入口-x2F-返回逻辑-trap-以及中断处理函数-（-trap-handler-）" class="headerlink" title="3.修改中断入口&#x2F;返回逻辑 ( _trap ) 以及中断处理函数 （ trap_handler ）"></a>3.修改中断入口&#x2F;返回逻辑 ( _trap ) 以及中断处理函数 （ trap_handler ）</h3><ul><li>与 ARM 架构不同的是，RISC-V 中只有一个栈指针寄存器( sp )，因此需要我们来完成用户栈与内核栈的切换。</li><li>由于我们的用户态进程运行在 <code>U-Mode</code> 下， 使用的运行栈也是 <code>U-Mode Stack</code>， 因此当触发异常时， 我们首先要对栈进行切换 （ <code>U-Mode Stack</code> -&gt; <code>S-Mode Stack</code> ）。同理 让我们完成了异常处理， 从 <code>S-Mode</code> 返回至 <code>U-Mode</code>， 也需要进行栈切换 （ <code>S-Mode Stack</code> -&gt; <code>U-Mode Stack</code> ）。</li><li>修改 <code>__dummy</code>。在 <strong>4.2</strong> 中 我们初始化时， <code>thread_struct.sp</code> 保存了 <code>S-Mode sp</code>， <code>thread_struct.sscratch</code> 保存了 <code>U-Mode sp</code>， 因此在 <code>S-Mode -&gt; U-&gt;Mode</code> 的时候，我们只需要交换对应的寄存器的值即可。</li></ul><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">__dummy:</span><br>    STACK_CHANGE t0<br>    <span class="hljs-meta"># la t0,dummy</span><br>    <span class="hljs-meta"># csrw sepc,t0</span><br>    sret<br></code></pre></td></tr></table></figure><ul><li>修改 <code>_trap</code> 。同理 在 <code>_trap</code> 的首尾我们都需要做类似的操作。<strong>注意如果是 内核线程( 没有 U-Mode Stack ) 触发了异常，则不需要进行切换。（内核线程的 sp 永远指向的 S-Mode Stack， sscratch 为 0）</strong></li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-symbol">_traps:</span><br>    <span class="hljs-comment"># YOUR CODE HERE</span><br>    <span class="hljs-comment"># -----------</span><br>    csrr <span class="hljs-built_in">t0</span>,sscratch<br>    <span class="hljs-keyword">beq </span><span class="hljs-built_in">t0</span>,<span class="hljs-built_in">zero</span>,_traps_switch<br>    STACK_CHANGE <span class="hljs-built_in">t0</span><br><span class="hljs-symbol">_traps_switch:</span><br><span class="hljs-comment">#details omitted</span><br>    <br>    csrr <span class="hljs-built_in">t0</span>,sscratch<br>    <span class="hljs-keyword">beq </span><span class="hljs-built_in">t0</span>,<span class="hljs-built_in">zero</span>,_traps_end<br>    STACK_CHANGE <span class="hljs-built_in">t0</span><br><span class="hljs-symbol">_traps_end:</span><br></code></pre></td></tr></table></figure><ul><li><code>uapp</code> 使用 <code>ecall</code> 会产生 <code>ECALL_FROM_U_MODE</code> <strong>exception</strong>。因此我们需要在 <code>trap_handler</code> 里面进行捕获。修改 <code>trap_handler</code> 如下：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">trap_handler</span><span class="hljs-params">(<span class="hljs-type">uint64_t</span> scause, <span class="hljs-type">uint64_t</span> sepc, <span class="hljs-keyword">struct</span> pt_regs *regs)</span> &#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>regs参数用来传递<code>sepc</code>和<code>a0~a7</code>寄存器的值，下面补充<code>struct pt_regs</code>的定义和<code>trap_handler</code>的实现。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pt_regs</span>&#123;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sepc;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> x[<span class="hljs-number">30</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">trap_handler</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> scause, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sepc, <span class="hljs-keyword">struct</span> pt_regs *regs)</span> &#123;<br>    <span class="hljs-comment">// YOUR CODE HERE</span><br>    <span class="hljs-keyword">if</span>(scause == <span class="hljs-number">0x8000000000000005</span>)<br>    &#123;<br>        <span class="hljs-comment">//printk(&quot;[S] Supervisor Mode Timer Interrupt \n&quot;);</span><br>        clock_set_next_event();<br>        do_timer();<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(scause == <span class="hljs-number">0x8</span>)<br>    &#123;<br>        <span class="hljs-comment">//printk(&quot;syscall\n&quot;);</span><br>        syscall(regs);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        printk(<span class="hljs-string">&quot;unhandled trap:%lx\n&quot;</span>,scause);<br>        printk(<span class="hljs-string">&quot;sepc:%lx\n&quot;</span>,sepc);<br>        printk(<span class="hljs-string">&quot;regs:%lx\n&quot;</span>,&amp;regs);<br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-添加系统调用"><a href="#4-添加系统调用" class="headerlink" title="4.添加系统调用"></a>4.添加系统调用</h3><ul><li>本次实验要求的系统调用函数原型以及具体功能如下：<ul><li>64 号系统调用 <code>sys_write(unsigned int fd, const char* buf, size_t count)</code> 该调用将用户态传递的字符串打印到屏幕上，此处fd为标准输出（1），buf为用户需要打印的起始地址，count为字符串长度，返回打印的字符数。( 具体见 user&#x2F;printf.c )</li><li>172 号系统调用 <code>sys_getpid()</code> 该调用从current中获取当前的pid放入a0中返回，无参数。（ 具体见 user&#x2F;getpid.c ）</li></ul></li><li>增加 <code>syscall.c</code> <code>syscall.h</code> 文件， 并在其中实现 <code>getpid</code> 以及 <code>write</code> 逻辑。</li><li>系统调用的返回参数放置在 <code>a0</code> 中 (不可以直接修改寄存器， 应该修改 regs 中保存的内容)。</li><li>针对系统调用这一类异常， 我们需要手动将 <code>sepc + 4</code> （ <code>sepc</code> 记录的是触发异常的指令地址， 由于系统调用这类异常处理完成之后， 我们应该继续执行后续的指令，因此需要我们手动修改 <code>spec</code> 的地址，使得 <code>sret</code> 之后 程序继续执行）。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//syscall.h</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;defs.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SYS_WRITE   64</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SYS_GETPID  172</span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pt_regs</span>&#123;</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sepc;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> x[<span class="hljs-number">30</span>];<br>&#125;;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">syscall</span><span class="hljs-params">( <span class="hljs-keyword">struct</span> pt_regs* regs )</span>;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//syscall.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;syscall.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;proc.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;printk.h&quot;</span></span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> *<span class="hljs-title">current</span>;</span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">syscall</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pt_regs* regs)</span><br>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    for(int i=0;i&lt;30;i++)</span><br><span class="hljs-comment">        printk(&quot;reg[%d]:%d\n&quot;,i,regs-&gt;x[i]);</span><br><span class="hljs-comment">    while(1);</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-keyword">if</span> (regs-&gt;x[<span class="hljs-number">15</span>] == SYS_WRITE)<br>    &#123;<br>        <span class="hljs-type">char</span> *str = (<span class="hljs-type">char</span>*)regs-&gt;x[<span class="hljs-number">9</span>];<br>        uint64 len = regs-&gt;x[<span class="hljs-number">10</span>];<br>        str[len] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>        printk(str);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (regs-&gt;x[<span class="hljs-number">15</span>] == SYS_GETPID)<br>    &#123;<br>        regs-&gt;x[<span class="hljs-number">8</span>] = current-&gt;pid;<br>    &#125;<br>    regs-&gt;sepc += <span class="hljs-number">0x4</span>;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-修改head-S以及start-kernel"><a href="#5-修改head-S以及start-kernel" class="headerlink" title="5.修改head.S以及start_kernel"></a>5.修改head.S以及start_kernel</h3><ul><li>之前 lab 中， 在 OS boot 之后，我们需要等待一个时间片，才会进行调度。我们现在更改为 OS boot 完成之后立即调度 uapp 运行。</li><li>在 start_kernel 中调用 schedule() 注意放置在 test() 之前。</li><li>将 head.S 中 enable interrupt sstatus.SIE 逻辑注释，确保 schedule 过程不受中断影响。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-built_in">set</span> sstatus[SIE] = 1</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">csrsi sstatus,1&lt;&lt;<span class="hljs-string">1</span></span><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">start_kernel</span><span class="hljs-params">()</span> &#123;<br>    <br>    printk(<span class="hljs-string">&quot;[S-MODE]%d Hello RISC-V\n&quot;</span>,<span class="hljs-number">2022</span>);<br>    <span class="hljs-comment">//printk(&quot;idle process is running\n&quot;);</span><br>    schedule();<br>    test(); <span class="hljs-comment">// DO NOT DELETE !!!</span><br>    <br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="编译与测试"><a href="#编译与测试" class="headerlink" title="编译与测试"></a>编译与测试</h3><p><img src="https://typora-lqy.oss-cn-hangzhou.aliyuncs.com/image/image-20221228162941403.png" alt="编译运行结果"></p><h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><ol><li><p>我们在实验中使用的用户态线程和内核态线程的对应关系是怎样的？（一对一，一对多，多对一还是多对多）</p><p>多对一</p></li><li><p>为什么 Phdr 中，<code>p_filesz</code> 和 <code>p_memsz</code> 是不一样大的？</p><p><code>p_filesz</code>对应文件中该段的大小，<code>p_memsz</code>对应该段的内存中大小，可加载段可能包含<code>.bss</code>节，该节包含未初始化的数据。将此数据存储在磁盘上会很浪费，因此仅在ELF文件加载到内存后才占用空间。</p></li><li><p>为什么多个进程的栈虚拟地址可以是相同的？用户有没有常规的方法知道自己栈所在的物理地址？</p><p>因为虚拟地址是通过<code>create_mapping</code>函数创建的与物理地址的映射，不同进程对应的所在的物理地址是不同的，所以栈虚拟地址相同也没有关系。可以在<code>task_init</code>函数中将不同进程的栈所在的物理地址print出来。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="操作系统" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="os实验报告" scheme="http://example.com/tags/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    
  </entry>
  
  <entry>
    <title>oslab4_report</title>
    <link href="http://example.com/2023/07/08/oslab4-report/"/>
    <id>http://example.com/2023/07/08/oslab4-report/</id>
    <published>2023-07-08T06:45:33.000Z</published>
    <updated>2023-07-29T05:52:30.886Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="lab4实验报告"><a href="#lab4实验报告" class="headerlink" title="lab4实验报告"></a>lab4实验报告</h3><h4 id="开启虚拟内存映射"><a href="#开启虚拟内存映射" class="headerlink" title="开启虚拟内存映射"></a>开启虚拟内存映射</h4><p>在lab4中，开启虚拟内存映射被分为了2步，分别为<code>setup_vm</code>和<code>setup_vm_final</code>，具体实现如下</p><h5 id="setup-vm的实现"><a href="#setup-vm的实现" class="headerlink" title="setup_vm的实现"></a><code>setup_vm</code>的实现</h5><p>将 0x80000000 开始的 1GB 区域进行两次映射，其中一次是等值映射 ( PA &#x3D;&#x3D; VA ) ，另一次是将其映射至高地址 ( PA + PV2VA_OFFSET &#x3D;&#x3D; VA )</p><h6 id="相关宏定义"><a href="#相关宏定义" class="headerlink" title="相关宏定义"></a>相关宏定义</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> VPN2(va) ( (va&gt;&gt;30) &amp; 0x1ff )</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> VPN1(va) ( (va&gt;&gt;21) &amp; 0x1ff )</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> VPN0(va) ( (va&gt;&gt;12) &amp; 0x1ff )</span><br></code></pre></td></tr></table></figure><p><code>linear_mapping</code>函数</p><p><code>linear_mapping</code>仿照<code>create_mapping</code>函数创建，用于创建单级页表线性映射关系，其中由于在<code>setup_vm</code>中权限位都为15，所以只需要传递3个参数。</p><p>观察SV39模式物理地址的布局</p><p><img src="https://typora-lqy.oss-cn-hangzhou.aliyuncs.com/image/image-20221207121050653.png" alt="SV39Mode物理地址布局"></p><p>1G为$2^{30}$，所以使用PPN[2]作为物理地址的页表好，后30位作为偏移量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">linear_mapping</span><span class="hljs-params">( <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> *pgtbl, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> va, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> pa )</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> index = <span class="hljs-built_in">VPN2</span>(va);<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> PPN = (pa&gt;&gt;<span class="hljs-number">30</span>) &amp; <span class="hljs-number">0x3ffffff</span>;<br>    pgtbl[index] = (<span class="hljs-number">15</span>) | PPN&lt;&lt;<span class="hljs-number">28</span>;<br><br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>setup_vm</code>函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setup_vm</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>    <span class="hljs-comment">/* </span><br><span class="hljs-comment">    1. 由于是进行 1GB 的映射 这里不需要使用多级页表 </span><br><span class="hljs-comment">    2. 将 va 的 64bit 作为如下划分： | high bit | 9 bit | 30 bit |</span><br><span class="hljs-comment">        high bit 可以忽略</span><br><span class="hljs-comment">        中间9 bit 作为 early_pgtbl 的 index</span><br><span class="hljs-comment">        低 30 bit 作为 页内偏移 这里注意到 30 = 9 + 9 + 12， 即我们只使用根页表， 根页表的每个 entry 都对应 1GB 的区域。 </span><br><span class="hljs-comment">    3. Page Table Entry 的权限 V | R | W | X 位设置为 1</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> pa = PHY_START;<br>   <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> va = PHY_START;<br>   <span class="hljs-type">int</span> index;<br>   <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> PPN;<br>   <span class="hljs-built_in">memset</span>(early_pgtbl,<span class="hljs-number">0x0</span>,PGSIZE);<br><br>   <span class="hljs-built_in">linear_mapping</span>(early_pgtbl,va,pa);<br><br>   va = VM_START;<br>   <span class="hljs-built_in">linear_mapping</span>(early_pgtbl,va,pa);<br>   <br>   <span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;...setup_vm done!\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在完成<code>setup_vm</code>函数之后，需要对<code>head.S</code>进行修改</p><p>在汇编代码起始处调用<code>setup_vm</code>函数和<code>relocate</code>，其中<code>relote</code>汇编代码段执行对<code>satp</code>寄存器的修改，具体实现如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs riscv">relocate:<br><br>    # set ra = ra + PA2VA_OFFSET<br>    # set sp = sp + PA2VA_OFFSET (If you have set the sp before)<br>    li t0, PA2VA_OFFSET<br>    add ra, ra, t0<br>    add sp, sp, t0<br><br>    # set satp with early_pgtbl<br>    # satp[PPN] &lt;= early_pgtbl / 2^12 (根页表地址/4KB 即为根页表在物理页*上的页号)<br>    la t0, early_pgtbl<br>    srli t0, t0, 12<br>    # satp[ASID] &lt;= 0<br>    li t1, 0x00000fffffffffff<br>    and t0, t0, t1<br>    # satp[MODE] &lt;= 8 意为Sv39模式<br>    li t1, 0x8000000000000000<br>    or t0, t0, t1<br>    csrw satp, t0<br><br>    # flush tlb<br>    sfence.vma zero, zero<br><br>    # flush icache<br>    fence.i<br><br>    ret<br></code></pre></td></tr></table></figure><p>自此已经完成了虚拟地址的开启</p><h5 id="setup-vm-final的实现"><a href="#setup-vm-final的实现" class="headerlink" title="setup_vm_final的实现"></a><code>setup_vm_final</code>的实现</h5><p>由于<code>setup_vm_final</code>中需要申请页面的接口， 应该在其之前完成内存管理初始化，需要修改 mm.c 中的代码，mm.c 中初始化的函数接收的起始结束地址需要调整为虚拟地址&#96;&#96;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mm_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>    <span class="hljs-built_in">kfreerange</span>(_ekernel, (<span class="hljs-type">char</span> *)PHY_END+PA2VA_OFFSET);<br>    <span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;...mm_init done!\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>create_mapping()</code>函数用于创建多级页表映射关系，传递了4个参数，分别为根页表地址，待映射的物理地址和虚拟地址，权限。</p><p>在函数开始，声明了3个函数中将会使用的数组，如下</p><ul><li><code>unsigned int vpn[3];</code><em>存储三、二、一级页表中所求PTE的偏移量</em></li><li><code>unsigned long* v_pgtbl[3];</code><em>存储三、二、一级页表的虚拟地址</em></li><li><code>unsigned long pte[3];</code><em>存储三、二、一级页表中所求PTE的值</em></li></ul><p><code>create_mapping()</code>函数中，每次循环映射一页4KB的物理地址到虚拟地址，具体流程如下</p><ol><li>将根页表的基地址作为<code>v_pgtbl[2]</code>，根据<code>v_pgtbl[2]</code>和<code>vpn[2]</code>得到 PTE 的内容 <code>pte[2]</code></li><li>若 PTE 的有效位 V 为 0，则申请一块内存空间作为新的二级页表，并将新建的二级页表的地址存放到 PTE 中，并将有效位 V 置 1</li><li>根据 PTE 的内容求出二级页表的虚拟地址，在二级页表中用同样的方法新建一个一级页表或求得一级页表的地址</li><li>在一级页表中求得 PTE 的地址，将物理地址存入 PTE，将有效位 V 置 1，根据<code>perm</code>改写 RWX 权限位</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/* 创建多级页表映射关系 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">create_mapping</span><span class="hljs-params">(uint64 *pgtbl, uint64 va, uint64 pa, uint64 sz, <span class="hljs-type">int</span> perm)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">    pgtbl 为根⻚表的基地址</span><br><span class="hljs-comment">    va, pa 为需要映射的段的开头的虚拟地址、物理地址</span><br><span class="hljs-comment">    sz 为需要映射的段的⼤⼩</span><br><span class="hljs-comment">    perm 为映射的读写权限，可设置不同section所在⻚的属性，完成对不同section的保护</span><br><span class="hljs-comment">    创建多级⻚表的时候可以使⽤ kalloc() 来获取⼀⻚作为⻚表⽬录</span><br><span class="hljs-comment">    可以使⽤ V bit 来判断⻚表项是否存在</span><br><span class="hljs-comment">*/</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> vpn[<span class="hljs-number">3</span>]; <span class="hljs-comment">// 存储三、二、一级页表中所求PTE的偏移量</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>* v_pgtbl[<span class="hljs-number">3</span>]; <span class="hljs-comment">// 存储三、二、一级页表的虚拟地址</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> pte[<span class="hljs-number">3</span>]; <span class="hljs-comment">// 存储三、二、一级页表中所求PTE的值</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>* page;<br><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> end = va + sz;<br><br>    <span class="hljs-keyword">while</span>( va &lt; end )<br>    &#123;<br>        v_pgtbl[<span class="hljs-number">2</span>] = pgtbl;<br>        vpn[<span class="hljs-number">2</span>] = <span class="hljs-built_in">VPN2</span>(va);<br>        pte[<span class="hljs-number">2</span>] = v_pgtbl[<span class="hljs-number">2</span>][vpn[<span class="hljs-number">2</span>]];<br>        <span class="hljs-keyword">if</span>(!(pte[<span class="hljs-number">2</span>]&amp;<span class="hljs-number">1</span>))<br>        &#123;<br>            page = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>*)<span class="hljs-built_in">kalloc</span>();<br>            pte[<span class="hljs-number">2</span>] = ((((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)page-PA2VA_OFFSET) &gt;&gt; <span class="hljs-number">12</span>) &lt;&lt; <span class="hljs-number">10</span>) | <span class="hljs-number">1</span>;<br>            v_pgtbl[<span class="hljs-number">2</span>][vpn[<span class="hljs-number">2</span>]] = pte[<span class="hljs-number">2</span>];<br>        &#125;<br><br>        v_pgtbl[<span class="hljs-number">1</span>] = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>*)(((pte[<span class="hljs-number">2</span>] &gt;&gt; <span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-number">12</span>)+PA2VA_OFFSET);<br>        vpn[<span class="hljs-number">1</span>] = <span class="hljs-built_in">VPN1</span>(va);<br>        pte[<span class="hljs-number">1</span>] = v_pgtbl[<span class="hljs-number">1</span>][vpn[<span class="hljs-number">1</span>]];<br>        <span class="hljs-keyword">if</span>(!(pte[<span class="hljs-number">1</span>]&amp;<span class="hljs-number">1</span>))<br>        &#123;<br>            page = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>*)<span class="hljs-built_in">kalloc</span>();<br>            pte[<span class="hljs-number">1</span>] = ((((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)page-PA2VA_OFFSET) &gt;&gt; <span class="hljs-number">12</span>) &lt;&lt; <span class="hljs-number">10</span>) | <span class="hljs-number">1</span>;<br>            v_pgtbl[<span class="hljs-number">1</span>][vpn[<span class="hljs-number">1</span>]] = pte[<span class="hljs-number">1</span>];<br>        &#125;<br><br>        v_pgtbl[<span class="hljs-number">0</span>] = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>*)(((pte[<span class="hljs-number">1</span>] &gt;&gt; <span class="hljs-number">10</span>) &lt;&lt; <span class="hljs-number">12</span>)+PA2VA_OFFSET);<br>        vpn[<span class="hljs-number">0</span>] = <span class="hljs-built_in">VPN0</span>(va);<br>        pte[<span class="hljs-number">0</span>] = (perm &amp; <span class="hljs-number">15</span>) | ((pa &gt;&gt; <span class="hljs-number">12</span>) &lt;&lt; <span class="hljs-number">10</span>);<br>        v_pgtbl[<span class="hljs-number">0</span>][vpn[<span class="hljs-number">0</span>]] = pte[<span class="hljs-number">0</span>];<br><br>        va += PGSIZE;<br>        pa += PGSIZE;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>setup_vm_final</code>函数</p><p>在<code>setup_vm_final()</code>中调用<code>create_mapping()</code>函数，对128MB物理内存进行映射，其中<code>.text</code>段的权限设置为 X | - | R | V，<code>.rodata</code>段的权限设置为 - | - | R | V，其余内存的权限设置为 - | W | R | V。为了确定各段的起始地址，从<code>vmlinux.lds</code>引入如下外部变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">extern</span> <span class="hljs-type">char</span> _stext[];<br><span class="hljs-keyword">extern</span> <span class="hljs-type">char</span> _srodata[];<br><span class="hljs-keyword">extern</span> <span class="hljs-type">char</span> _sdata[];<br></code></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setup_vm_final</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span>(swapper_pg_dir, <span class="hljs-number">0x0</span>, PGSIZE);<br><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> va = VM_START+OPENSBI_SIZE;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> pa = PHY_START+OPENSBI_SIZE;<br>    <span class="hljs-comment">// No OpenSBI mapping required</span><br><br>    <span class="hljs-comment">// mapping kernel text X|-|R|V</span><br>    <span class="hljs-built_in">create_mapping</span>(swapper_pg_dir,va,pa,(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)_srodata-(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)_stext,<span class="hljs-number">11</span>);<br><br>    <span class="hljs-comment">// mapping kernel rodata -|-|R|V</span><br>    va += (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)_srodata-(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)_stext;<br>    pa += (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)_srodata-(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)_stext;<br>    <span class="hljs-built_in">create_mapping</span>(swapper_pg_dir,va,pa,(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)_sdata-(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)_srodata,<span class="hljs-number">3</span>);<br><br>    <span class="hljs-comment">// mapping other memory -|W|R|V</span><br>    va += (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)_sdata-(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)_srodata;<br>    pa += (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)_sdata-(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)_srodata;<br>    <span class="hljs-built_in">create_mapping</span>(swapper_pg_dir,va,pa,<span class="hljs-number">0x8000000</span>-((<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)_sdata-(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)_stext),<span class="hljs-number">7</span>);<br><br>    <span class="hljs-comment">// set satp with swapper_pg_dir</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> PG_DIR = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)swapper_pg_dir-PA2VA_OFFSET;<br>    <span class="hljs-function"><span class="hljs-keyword">asm</span> <span class="hljs-title">volatile</span> <span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-string">&quot;li t0, 8\n&quot;</span></span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-string">&quot;slli t0, t0, 60\n&quot;</span></span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-string">&quot;mv t1, %[PG_DIR]\n&quot;</span></span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-string">&quot;srli t1, t1, 12\n&quot;</span></span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-string">&quot;add t0, t0, t1\n&quot;</span></span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-string">&quot;csrw satp, t0&quot;</span></span></span><br><span class="hljs-params"><span class="hljs-function">        :</span></span><br><span class="hljs-params"><span class="hljs-function">        :[PG_DIR]<span class="hljs-string">&quot;r&quot;</span>(PG_DIR)</span></span><br><span class="hljs-params"><span class="hljs-function">        :<span class="hljs-string">&quot;memory&quot;</span></span></span><br><span class="hljs-params"><span class="hljs-function">    )</span></span>;<br><br>    <span class="hljs-comment">// flush TLB</span><br>    <span class="hljs-function"><span class="hljs-keyword">asm</span> <span class="hljs-title">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;sfence.vma zero, zero&quot;</span>)</span></span>;<br><br>    <span class="hljs-comment">// flush icache</span><br>    <span class="hljs-function"><span class="hljs-keyword">asm</span> <span class="hljs-title">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;fence.i&quot;</span>)</span></span>;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现完成后，在<code>head.S</code>中适当的位置调用<code>setup_vm_final</code>，<code>head.S</code>补全后的逻辑如下(只显示_start段)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs riscv">_start:<br><br>    la sp,boot_stack_top<br><br>    call setup_vm<br>    call relocate<br><br>    call mm_init<br><br>    call setup_vm_final<br><br>    call task_init<br>    <br>    # 以下省略设置时间中断部分<br>    <br>    call start_kernel<br></code></pre></td></tr></table></figure><p>同时，为了输出效果与github上一致，修改了部分lab3中代码，在此不做呈现</p><h4 id="编译与测试"><a href="#编译与测试" class="headerlink" title="编译与测试"></a>编译与测试</h4><p><img src="https://typora-lqy.oss-cn-hangzhou.aliyuncs.com/image/image-20221207124554542.png" alt="编译测试结果"></p><p>###思考题</p><ol><li><p>验证 <code>.text</code>, <code>.rodata</code> 段的属性是否成功设置，给出截图。</p><p>程序能正常运行，说明<code>.text</code>的X位设置成功</p><p>在<code>main.c</code>中添加代码尝试对段进行读操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">extern</span> <span class="hljs-type">char</span> _stext[];<br><span class="hljs-keyword">extern</span> <span class="hljs-type">char</span> _srodata[];<br><br><span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;_stext = %ld\n&quot;</span>, *_stext);<br><span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;_srodata = %ld\n&quot;</span>, *_srodata);<br></code></pre></td></tr></table></figure><p>运行结果如下</p><p><img src="https://typora-lqy.oss-cn-hangzhou.aliyuncs.com/image/image-20221207125428762.png" alt="验证读操作权限"></p><p>说明两段的R位设置成功</p><p>在<code>main.c</code>中尝试对其进行修改</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++">*_stext = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;_stext = %ld\n&quot;</span>, *_stext);<br>*_srodata = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;_srodata = %ld\n&quot;</span>, *_srodata);<br></code></pre></td></tr></table></figure><p>运行结果如下</p><p><img src="https://typora-lqy.oss-cn-hangzhou.aliyuncs.com/image/image-20221207125854680.png" alt="验证写操作权限"></p><p>可以发现写操作后面的输出语句并没有执行，说明没有写操作权限</p></li><li><p>为什么我们在 <code>setup_vm</code> 中需要做等值映射?</p><p>因为汇编代码在读取当前指令的同时会直接将pc指向下一条指令，在<code>csrw satp</code>之后，地址已经全部变为虚拟地址，而pc此时在还未执行时已经取到了下一条指令，即下一条指令的物理地址，但是执行下一条指令时，操作系统会认为我们运行在虚拟内存上，会通过映射去寻找虚拟内存对应的物理内存，但是pc此时实际上存储的就是物理内存，此时去做映射无法找到对应的物理地址，会发生缺页中断，而等值映射相当于是在代码的物理地址处也开辟了 一块虚拟内存，在这一段地址建立了物理地址和虚拟地址的一一对应关系，这样就可以通过映射找到物理地址了</p></li><li><p>在 Linux 中，是不需要做等值映射的。请探索一下不在 <code>setup_vm</code> 中做等值映射的方法。</p><p>不做等值映射的话会发生缺页异常。有一个思路是利用缺页异常，在发生缺页异常时，进入用户自己设定的异常处理程序，与lab2处理时间中断类似，在中断处理程序中重新设置sepc的值，将其设置为<code>pc+PA2VA_OFFSET</code>，这样退出中断后程序就会读取虚拟地址上的汇编代码段。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="操作系统" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="os实验报告" scheme="http://example.com/tags/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    
  </entry>
  
  <entry>
    <title>oslab3_report</title>
    <link href="http://example.com/2023/07/08/oslab3-report/"/>
    <id>http://example.com/2023/07/08/oslab3-report/</id>
    <published>2023-07-08T06:45:28.000Z</published>
    <updated>2023-07-29T05:52:30.885Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="Lab3实验报告"><a href="#Lab3实验报告" class="headerlink" title="Lab3实验报告"></a>Lab3实验报告</h3><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><h5 id="线程初始化"><a href="#线程初始化" class="headerlink" title="线程初始化"></a>线程初始化</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">task_init</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 1. 调用 kalloc() 为 idle 分配一个物理页</span><br>    idle = (<span class="hljs-keyword">struct</span> task_struct*)<span class="hljs-built_in">kalloc</span>();<br><br>    <span class="hljs-comment">// 2. 设置 state 为 TASK_RUNNING;</span><br>    idle-&gt;state = TASK_RUNNING;<br>    <br>    <span class="hljs-comment">// 3. 由于 idle 不参与调度 可以将其 counter / priority 设置为 0</span><br>    idle-&gt;counter = <span class="hljs-number">0</span>;<br>    idle-&gt;priority = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 4. 设置 idle 的 pid 为 0</span><br>    idle-&gt;pid = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 5. 将 current 和 task[0] 指向 idle</span><br>    current = idle;<br>    task[<span class="hljs-number">0</span>] = idle;<br><br>    <br><br>    <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 1. 参考 idle 的设置, 为 task[1] ~ task[NR_TASKS - 1] 进行初始化</span><br>    <span class="hljs-keyword">for</span>(;i&lt;NR_TASKS;i++)<br>    &#123;<br>        task[i]=(<span class="hljs-keyword">struct</span> task_struct*)<span class="hljs-built_in">kalloc</span>();<br>        <span class="hljs-comment">// 2. 其中每个线程的 state 为 TASK_RUNNING, counter 为 0, priority 使用 rand() 来设置, pid 为该线程在线程数组中的下标。</span><br>        task[i]-&gt;state = TASK_RUNNING;<br>        task[i]-&gt;counter = <span class="hljs-number">0</span>;<br>        task[i]-&gt;priority = <span class="hljs-built_in">rand</span>()%(PRIORITY_MAX-PRIORITY_MIN+<span class="hljs-number">1</span>)+PRIORITY_MIN;<br>        task[i]-&gt;pid = i;<br>        <span class="hljs-comment">// 3. 为 task[1] ~ task[NR_TASKS - 1] 设置 `thread_struct` 中的 `ra` 和 `sp`,</span><br>        <span class="hljs-comment">// 4. 其中 `ra` 设置为 __dummy （见 4.3.2）的地址,  `sp` 设置为 该线程申请的物理页的高地址</span><br>        task[i]-&gt;thread.ra = (uint64)__dummy;<br>        task[i]-&gt;thread.sp = (uint64)task[i]+PGSIZE;<br>    &#125;<br><br>    <span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;...proc_init done!\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="dummy"><a href="#dummy" class="headerlink" title="__dummy"></a>__dummy</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs riscv">__dummy:<br>    la t0,dummy<br>    csrw sepc,t0<br>    sret<br></code></pre></td></tr></table></figure><p>__dummy是context switch时调用的代码，负责将sepc设置为dummy的地址，在退出中断时执行dummy函数。</p><h5 id="实现线程切换"><a href="#实现线程切换" class="headerlink" title="实现线程切换"></a>实现线程切换</h5><p><code>void switch_to(struct task*next)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">switch_to</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> task_struct* next)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(current!=next)<br>    &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> SJF</span><br>            <span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;switch to [PID = %d COUNTER = %d]\n&quot;</span>,next-&gt;pid,next-&gt;counter);<br>        <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>        <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> PRIORITY</span><br>            <span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;switch to [PID = %d PRIORITY = %d COUNTER = %d]\n&quot;</span>,next-&gt;pid,next-&gt;priority,next-&gt;counter);<br>        <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">task_struct</span>* prev = current;<br>        current = next;<br>        __switch_to(prev,next);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> ;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用<code>__switch_to</code>实现线程切换</p><p><code>__switch_to</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs riscv">__switch_to:<br>    # save state to prev process<br>    addi t0,a0,40<br>    sd ra,0(t0)<br>    sd sp,8(t0)<br><br>    addi t0,a0,56<br>    sd s0,0(t0)<br>    sd s1,8(t0)<br>    sd s2,16(t0)<br>    sd s3,24(t0)<br>    sd s4,32(t0)<br>    sd s5,40(t0)<br>    sd s6,48(t0)<br>    sd s7,56(t0)<br>    sd s8,64(t0)<br>    sd s9,72(t0)<br>    sd s10,80(t0)<br>    sd s11,88(t0)<br><br>    # restore state from next process<br>    addi t0,a1,40<br>    ld ra,0(t0)<br>    ld sp,8(t0)<br><br>    addi t0,a1,56<br>    ld s0,0(t0)<br>    ld s1,8(t0)<br>    ld s2,16(t0)<br>    ld s3,24(t0)<br>    ld s4,32(t0)<br>    ld s5,40(t0)<br>    ld s6,48(t0)<br>    ld s7,56(t0)<br>    ld s8,64(t0)<br>    ld s9,72(t0)<br>    ld s10,80(t0)<br>    ld s11,88(t0)<br><br>    ret<br></code></pre></td></tr></table></figure><p>保存当前进程与函数调用相关的寄存器并将下一个进程保存的相关寄存器的值load到寄存器中。</p><h5 id="实现调度入口函数"><a href="#实现调度入口函数" class="headerlink" title="实现调度入口函数"></a>实现调度入口函数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">do_timer</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 1. 如果当前线程是 idle 线程 直接进行调度</span><br>    <span class="hljs-comment">// 2. 如果当前线程不是 idle 对当前线程的运行剩余时间减1 若剩余时间仍然大于0 则直接返回 否则进行调度</span><br>    <span class="hljs-keyword">if</span>(current==idle)<br>    &#123;<br>        <span class="hljs-built_in">schedule</span>();<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        current-&gt;counter--;<br>        <span class="hljs-keyword">if</span>(current-&gt;counter&gt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> ;<br>        <span class="hljs-keyword">else</span> <span class="hljs-built_in">schedule</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="实现线程调度"><a href="#实现线程调度" class="headerlink" title="实现线程调度"></a>实现线程调度</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">schedule</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> SJF</span><br>        <span class="hljs-built_in">SJF_schedule</span>();<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> PRIORITY</span><br>        <span class="hljs-built_in">PRIORITY_schedule</span>();<br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br></code></pre></td></tr></table></figure><h6 id="短作业优先调度算法"><a href="#短作业优先调度算法" class="headerlink" title="短作业优先调度算法"></a>短作业优先调度算法</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SJF_schedule</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">task_struct</span>* next = current;<br>    uint64 flag = <span class="hljs-number">0</span>,min_counter = COUNTER_MAX + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;NR_TASKS;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(task[i]-&gt;counter!=<span class="hljs-number">0</span>)<br>        &#123;<br>            flag = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!flag)<br>    &#123;<br>        <span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;NR_TASKS;i++)<br>        &#123;<br>            task[i]-&gt;counter=<span class="hljs-built_in">rand</span>()%(COUNTER_MAX-COUNTER_MIN+<span class="hljs-number">1</span>)+COUNTER_MIN;<br>            <span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;SET [PID = %d COUNTER = %d]\n&quot;</span>,task[i]-&gt;pid,task[i]-&gt;counter);<br>        &#125;<br>        <span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;NR_TASKS;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(task[i]-&gt;state!=TASK_RUNNING||task[i]-&gt;counter==<span class="hljs-number">0</span>)<span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span>(task[i]-&gt;counter&lt;min_counter)<br>        &#123;<br>            min_counter = task[i]-&gt;counter;<br>            next = task[i];<br>        &#125;<br>    &#125;<br>    switch_to(next);<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h6 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PRIORITY_schedule</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">task_struct</span>* next = current;<br>    uint64 flag = <span class="hljs-number">0</span>,max_priority = PRIORITY_MIN - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;NR_TASKS;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(task[i]-&gt;counter!=<span class="hljs-number">0</span>)<br>        &#123;<br>            flag = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!flag)<br>    &#123;<br>        <span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;NR_TASKS;i++)<br>        &#123;<br>            task[i]-&gt;counter=<span class="hljs-built_in">rand</span>()%(COUNTER_MAX-COUNTER_MIN+<span class="hljs-number">1</span>)+COUNTER_MIN;<br>            <span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;SET [PID = %d PRIORITY = %d COUNTER = %d]\n&quot;</span>,task[i]-&gt;pid,task[i]-&gt;priority,task[i]-&gt;counter);<br>        &#125;<br>        <span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;NR_TASKS;i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(task[i]-&gt;state!=TASK_RUNNING||task[i]-&gt;counter==<span class="hljs-number">0</span>)<span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">if</span>(task[i]-&gt;priority&gt;max_priority)<br>        &#123;<br>            max_priority=task[i]-&gt;priority;<br>            next=task[i];<br>        &#125;<br>    &#125;<br>    switch_to(next);<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>两个算法思路类似，先遍历task-&gt;counter，如果全为0，则使用rand()函数对每一个进程的运行剩余时间重新赋值。此后从头开始遍历，寻找剩余时间最短的或优先级最高的进程，将其赋值给next，利用<code>switch_to()</code>进行进程切换。</p><h4 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h4><p>为方便截图，在以下测试结果中将<code>NR_TASKS</code>改为$1+5$。</p><p>短作业优先调度算法</p><p><img src="https://typora-lqy.oss-cn-hangzhou.aliyuncs.com/image/image-20221116185740338.png" alt="短作业优先调度"></p><p>优先级调度算法</p><p><img src="https://typora-lqy.oss-cn-hangzhou.aliyuncs.com/image/image-20221116190209083.png" alt="优先级调度"></p><h3 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h3><ol><li><p>中断的上下文需要保存所有的寄存器，<code>context_switch</code>属于函数调用，遵循函数调用的规则，所以只需要保存s0-11 12个callee saved register和ra，sp共14个寄存器。</p></li><li><p>在刚进入<code>__switch_to</code>时，ra存放的为<code>switch_to()</code>函数中调用<code>__switch_to</code>的地址</p><p><img src="https://typora-lqy.oss-cn-hangzhou.aliyuncs.com/image/image-20221116191534001.png"></p></li></ol><p>当执行完<code>ld ra,0(t0)</code>后，<code>next-&gt;thread.ra</code>被赋值给ra，ra存储的为<code>__dummy</code>的地址</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="操作系统" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="os实验报告" scheme="http://example.com/tags/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    
  </entry>
  
  <entry>
    <title>oslab2_report</title>
    <link href="http://example.com/2023/07/08/oslab2-report/"/>
    <id>http://example.com/2023/07/08/oslab2-report/</id>
    <published>2023-07-08T06:45:24.000Z</published>
    <updated>2023-07-29T05:52:30.885Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="Lab2实验报告"><a href="#Lab2实验报告" class="headerlink" title="Lab2实验报告"></a>Lab2实验报告</h3><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><h5 id="开启trap处理"><a href="#开启trap处理" class="headerlink" title="开启trap处理"></a>开启trap处理</h5><p><code>head.S</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.extern start_kernel<br><br>    .section .text.init<br>    .globl _start<br>_start:<br>    <br>    # set stvec = _traps   <br>    la t0,_traps<br>    csrw stvec,t0<br>    <br>    # set sie[STIE] = 1<br>    csrr t0,sie     # STIE为sie寄存器的第6位<br>    ori t0,t0,1&lt;&lt;5<br>    csrw sie,t0<br><br>    # set first time interrupt<br>    # 将a0设置成现在的时钟周期加1s(10000000 cycles)<br>    rdtime a0<br>    li a1,10000000<br>    add a0,a0,a1<br>    mv a1,zero<br>    mv a2,zero<br>    mv a3,zero<br>    mv a4,zero<br>    mv a5,zero<br>    mv a6,zero<br>    mv a7,zero<br>    ecall<br><br>    # set sstatus[SIE] = 1<br>    csrsi sstatus,1&lt;&lt;1  # SIE为sstatus寄存器的第2位<br><br>    # --------<br>    # Lab1 Code<br>    # --------<br>    la sp,boot_stack_top<br>    call start_kernel<br><br>    .section .bss.stack<br>    .globl boot_stack<br>boot_stack:<br>    .space 4096 # &lt;-- change to your stack size<br><br>    .globl boot_stack_top<br>boot_stack_top:.extern start_kernel<br><br>    .section .text.init<br>    .globl _start<br>_start:<br>    <br>    # set stvec = _traps   <br>    la t0,_traps<br>    csrw stvec,t0<br>    <br>    # set sie[STIE] = 1<br>    csrr t0,sie<br>    ori t0,t0,1&lt;&lt;5<br>    csrw sie,t0<br><br>    # set first time interrupt<br>    rdtime a0<br>    li a1,10000000<br>    add a0,a0,a1<br>    mv a1,zero<br>    mv a2,zero<br>    mv a3,zero<br>    mv a4,zero<br>    mv a5,zero<br>    mv a6,zero<br>    mv a7,zero<br>    ecall<br><br>    # set sstatus[SIE] = 1<br>    csrsi sstatus,1&lt;&lt;1<br><br>    # --------<br>    # Lab1 Code<br>    # --------<br>    la sp,boot_stack_top<br>    call start_kernel<br><br>    .section .bss.stack<br>    .globl boot_stack<br>boot_stack:<br>    .space 4096 # &lt;-- change to your stack size<br><br>    .globl boot_stack_top<br>boot_stack_top:<br></code></pre></td></tr></table></figure><h5 id="实现上下文切换"><a href="#实现上下文切换" class="headerlink" title="实现上下文切换"></a>实现上下文切换</h5><p><code>entry.S</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs assembly">    .section .text.entry<br>    .align 2<br>    .globl _traps <br>_traps:<br>    # YOUR CODE HERE<br>    # -----------<br><br>        # 1. save 32 registers and sepc to stack<br><br>    addi sp,sp,-248<br>    csrr a0,sepc<br>    sd a0,0(sp)<br><br>    sd x1,8(sp)<br>    sd x3,16(sp)<br>    sd x4,24(sp)<br>    sd x5,32(sp)<br>    sd x6,40(sp)<br>    sd x7,48(sp)<br>    sd x8,56(sp)<br>    sd x9,64(sp)<br>    sd x10,72(sp)<br>    sd x11,80(sp)<br>    sd x12,88(sp)<br>    sd x13,96(sp)<br>    sd x14,104(sp)<br>    sd x15,112(sp)<br>    sd x16,120(sp)<br>    sd x17,128(sp)<br>    sd x18,136(sp)<br>    sd x19,144(sp)<br>    sd x20,152(sp)<br>    sd x21,160(sp)<br>    sd x22,168(sp)<br>    sd x23,176(sp)<br>    sd x24,184(sp)<br>    sd x25,192(sp)<br>    sd x26,200(sp)<br>    sd x27,208(sp)<br>    sd x28,216(sp)<br>    sd x29,224(sp)<br>    sd x30,232(sp)<br>    sd x31,240(sp)<br>    # since x0 == 0 and x2 == sp, so x0 and x2 do not need to be stored<br>    # -----------<br><br>        # 2. call trap_handler<br>    csrr a0,scause<br>    csrr a1,sepc<br>    call trap_handler<br>    # -----------<br><br>        # 3. restore sepc and 32 registers (x2(sp) should be restore last) from stack<br>    ld a0,0(sp)<br>    csrw sepc,a0<br><br>    ld x1,8(sp)<br>    ld x3,16(sp)<br>    ld x4,24(sp)<br>    ld x5,32(sp)<br>    ld x6,40(sp)<br>    ld x7,48(sp)<br>    ld x8,56(sp)<br>    ld x9,64(sp)<br>    ld x10,72(sp)<br>    ld x11,80(sp)<br>    ld x12,88(sp)<br>    ld x13,96(sp)<br>    ld x14,104(sp)<br>    ld x15,112(sp)<br>    ld x16,120(sp)<br>    ld x17,128(sp)<br>    ld x18,136(sp)<br>    ld x19,144(sp)<br>    ld x20,152(sp)<br>    ld x21,160(sp)<br>    ld x22,168(sp)<br>    ld x23,176(sp)<br>    ld x24,184(sp)<br>    ld x25,192(sp)<br>    ld x26,200(sp)<br>    ld x27,208(sp)<br>    ld x28,216(sp)<br>    ld x29,224(sp)<br>    ld x30,232(sp)<br>    ld x31,240(sp)<br><br>    addi sp,sp,248<br>    # -----------<br><br>        # 4. return from trap<br>    sret<br>    # -----------<br><br></code></pre></td></tr></table></figure><h5 id="实现trap处理函数"><a href="#实现trap处理函数" class="headerlink" title="实现trap处理函数"></a>实现trap处理函数</h5><p><code>trap.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// trap.c </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;printk.h&quot;</span></span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> <span class="hljs-title function_">clock_set_next_event</span><span class="hljs-params">()</span>;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">trap_handler</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> scause, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sepc)</span> &#123;<br>    <span class="hljs-comment">// 通过 `scause` 判断trap类型</span><br>    <span class="hljs-comment">// 如果是interrupt 判断是否是timer interrupt</span><br>    <span class="hljs-comment">// 如果是timer interrupt 则打印输出相关信息, 并通过 `clock_set_next_event()` 设置下一次时钟中断</span><br>    <span class="hljs-comment">// `clock_set_next_event()` 见 4.5 节</span><br>    <span class="hljs-comment">// 其他interrupt / exception 可以直接忽略</span><br><br>    <span class="hljs-comment">// YOUR CODE HERE</span><br>    <span class="hljs-keyword">if</span>(scause == <span class="hljs-number">0x8000000000000005</span>)<br>    &#123;<br>        printk(<span class="hljs-string">&quot;[S] Supervisor Mode Timer Interrupt \n&quot;</span>);<br>        clock_set_next_event();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先判断是否是<code>interrupt</code>再判断是否为<code>timer interrupt</code></p><h5 id="实现时钟中断相关函数"><a href="#实现时钟中断相关函数" class="headerlink" title="实现时钟中断相关函数"></a>实现时钟中断相关函数</h5><p><code>clock.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// clock.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sbi.h&quot;</span></span><br><span class="hljs-comment">// QEMU中时钟的频率是10MHz, 也就是1秒钟相当于10000000个时钟周期。</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> TIMECLOCK = <span class="hljs-number">10000000</span>;<br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-title function_">get_cycles</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 编写内联汇编，使用 rdtime 获取 time 寄存器中 (也就是mtime 寄存器 )的值并返回</span><br>    <span class="hljs-comment">// YOUR CODE HERE</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> _cycles;<br>    __asm__ <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;rdtime %0&quot;</span> : <span class="hljs-string">&quot;=r&quot;</span>(_cycles))</span>;<br>    <span class="hljs-keyword">return</span> _cycles;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">clock_set_next_event</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 下一次 时钟中断 的时间点</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> next = get_cycles() + TIMECLOCK;<br><br>    <span class="hljs-comment">// 使用 sbi_ecall 来完成对下一次时钟中断的设置</span><br>    <span class="hljs-comment">// YOUR CODE HERE</span><br>    sbi_ecall(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,next,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>&#125; <br></code></pre></td></tr></table></figure><h5 id="编译测试结果"><a href="#编译测试结果" class="headerlink" title="编译测试结果"></a>编译测试结果</h5><p><img src="https://typora-lqy.oss-cn-hangzhou.aliyuncs.com/image/image-20221031103742307.png" alt="编译测试结果"></p><h4 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h4><p><code>mideleg</code>和<code>medeleg</code>合称为Machine Interrupt Delegation Register，为委托寄存器。</p><p>通常状态下，RISC-V架构下的所有trap都跳转到M-Mode进行处理。为了提高性能，RISC-V支持将低权限mode产生的trap委托给对应mode处理，其中涉及到<code>mideleg</code>和<code>medeleg</code>两个寄存器，其中<code>mideleg</code>寄存器控制将哪些中断委托给S-Mode处理。<code>mideleg</code>寄存器的结构与<code>mip</code>类似，<code>mideleg</code>的值为<code>0x0000000000000222</code>表示1、5、9位分别为1，分别对应SSIP、STIP、SEIP，表示这3种类型中断在S-Mode下委托给S-Mode处理。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="操作系统" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="os实验报告" scheme="http://example.com/tags/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    
  </entry>
  
  <entry>
    <title>oslab1_report</title>
    <link href="http://example.com/2023/07/08/oslab1-report/"/>
    <id>http://example.com/2023/07/08/oslab1-report/</id>
    <published>2023-07-08T06:45:19.000Z</published>
    <updated>2023-07-29T05:52:30.884Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="Lab1-实验报告"><a href="#Lab1-实验报告" class="headerlink" title="Lab1 实验报告"></a>Lab1 实验报告</h3><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p><code>head.S</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.extern start_kernel<br><br>    .section .text.entry<br>    .globl _start<br>_start:<br>    <br>    la sp,boot_stack_top #存放栈指针<br>    call start_kernel #调用start_kernel<br><br>    .section .bss.stack<br>    .globl boot_stack<br>boot_stack:<br>    .space 0x1000000 # &lt;-- change to your stack size<br><br>    .globl boot_stack_top<br>boot_stack_top:<br></code></pre></td></tr></table></figure><p><code>lib/Makefile</code></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs makefile">C_SRC       = <span class="hljs-variable">$(<span class="hljs-built_in">sort</span> $(<span class="hljs-built_in">wildcard</span> *.c)</span>)<br>OBJ    = <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %.c,%.o,<span class="hljs-variable">$(C_SRC)</span>)</span><br><br>file = print.o<br><span class="hljs-section">all:<span class="hljs-variable">$(OBJ)</span></span><br><br><span class="hljs-section">%.o:%.c</span><br>$&#123;GCC&#125; $&#123;CFLAG&#125; -c <span class="hljs-variable">$&lt;</span><br><span class="hljs-section">clean:</span><br><span class="hljs-variable">$(<span class="hljs-built_in">shell</span> rm *.o 2&gt;/dev/null)</span><br></code></pre></td></tr></table></figure><p>其中前两行定义了2个变量，<code>C_SRC</code>为所有的.c文件，<code>OBJ</code>变量为把<code>C_SRC</code>中所有的.c替换成.o</p><p><code>all:</code>指定了输出的伪目标为所有的.o文件</p><p><code>%.o:%.c</code>为.o和对应的.c文件指定了依赖关系</p><p><code>2&gt;/dev/null</code>将生成的垃圾文件重定向到<code>/dev/null</code>目录下，执行<code>make clean</code>后将这些文件删除</p><p><code>sbi.c</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;types.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sbi.h&quot;</span></span><br><br><br><span class="hljs-keyword">struct</span> sbiret <span class="hljs-title function_">sbi_ecall</span><span class="hljs-params">(<span class="hljs-type">int</span> ext, <span class="hljs-type">int</span> fid, uint64 arg0,</span><br><span class="hljs-params">            uint64 arg1, uint64 arg2,</span><br><span class="hljs-params">            uint64 arg3, uint64 arg4,</span><br><span class="hljs-params">            uint64 arg5)</span> <br>&#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sbiret</span> <span class="hljs-title">result</span>;</span><br>__asm__ <span class="hljs-title function_">volatile</span><span class="hljs-params">(</span><br><span class="hljs-params"><span class="hljs-string">&quot;mv a0, %[arg0]\n&quot;</span></span><br><span class="hljs-params"><span class="hljs-string">&quot;mv a1, %[arg1]\n&quot;</span></span><br><span class="hljs-params"><span class="hljs-string">&quot;mv a2, %[arg2]\n&quot;</span></span><br><span class="hljs-params"><span class="hljs-string">&quot;mv a3, %[arg3]\n&quot;</span></span><br><span class="hljs-params"><span class="hljs-string">&quot;mv a4, %[arg4]\n&quot;</span></span><br><span class="hljs-params"><span class="hljs-string">&quot;mv a5, %[arg5]\n&quot;</span></span><br><span class="hljs-params"><span class="hljs-string">&quot;mv a6, %[arg6]\n&quot;</span></span><br><span class="hljs-params"><span class="hljs-string">&quot;mv a7, %[arg7]\n&quot;</span></span><br><span class="hljs-params"><span class="hljs-string">&quot;ecall\n&quot;</span></span><br><span class="hljs-params"><span class="hljs-string">&quot;mv %[error], a0\n&quot;</span></span><br><span class="hljs-params"><span class="hljs-string">&quot;mv %[value], a1&quot;</span></span><br><span class="hljs-params">:[error] <span class="hljs-string">&quot;=r&quot;</span> (result.error), [value] <span class="hljs-string">&quot;=r&quot;</span> (result.value)</span><br><span class="hljs-params">:[arg0] <span class="hljs-string">&quot;r&quot;</span> (arg0), [arg1] <span class="hljs-string">&quot;r&quot;</span> (arg1), [arg2] <span class="hljs-string">&quot;r&quot;</span> (arg2), [arg3] <span class="hljs-string">&quot;r&quot;</span> (arg3), [arg4] <span class="hljs-string">&quot;r&quot;</span> (arg4), [arg5] <span class="hljs-string">&quot;r&quot;</span> (arg5), [arg6] <span class="hljs-string">&quot;r&quot;</span> (fid), [arg7] <span class="hljs-string">&quot;r&quot;</span> (ext)</span><br><span class="hljs-params">:<span class="hljs-string">&quot;memory&quot;</span></span><br><span class="hljs-params">)</span>;<br><br><span class="hljs-keyword">return</span> result;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><code>mv</code>语句用于将寄存器与变量<code>arg0</code>-<code>arg7</code>绑定，然后调用<code>ecall</code>指令，最后将<code>a0</code>和<code>a1</code>寄存器的值存到<code>result</code>中输出</p><p><code>puts()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">puts</span><span class="hljs-params">(<span class="hljs-type">char</span> *s)</span> &#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(s[i]!=<span class="hljs-string">&#x27;\0&#x27;</span>)<br>    &#123;<br>        sbi_ecall(<span class="hljs-number">0x1</span>,<span class="hljs-number">0x0</span>,(<span class="hljs-type">int</span>)s[i],<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>        i++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从头到尾依次调用<code>sbi_ecall</code>输出字符</p><p><code>puti()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">puti</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> &#123;<br>    <span class="hljs-type">int</span> a,b;<br><br>    <span class="hljs-keyword">if</span>(x &gt; <span class="hljs-number">0</span>)<br>    &#123;<br>        a = x%<span class="hljs-number">10</span>;<br>        b = x/<span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">if</span>(b != <span class="hljs-number">0</span>)<br>            puti(b);<br>        sbi_ecall(<span class="hljs-number">0x1</span>,<span class="hljs-number">0x0</span>,<span class="hljs-number">0x30</span>+a,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x == <span class="hljs-number">0</span>)<br>        sbi_ecall(<span class="hljs-number">0x1</span>,<span class="hljs-number">0x0</span>,<span class="hljs-number">0x30</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(x &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        x=-x;<br>        sbi_ecall(<span class="hljs-number">0x1</span>,<span class="hljs-number">0x0</span>,<span class="hljs-number">0x2d</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span>(x &gt; <span class="hljs-number">0</span>)<br>        &#123;<br>            a = x%<span class="hljs-number">10</span>;<br>            b = x/<span class="hljs-number">10</span>;<br>            <span class="hljs-keyword">if</span>(b != <span class="hljs-number">0</span>)<br>                puti(b);<br>            sbi_ecall(<span class="hljs-number">0x1</span>,<span class="hljs-number">0x0</span>,<span class="hljs-number">0x30</span>+a,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>先判断<code>x</code>的正负性，分类讨论，采用递归的方式输出</p><p><code>csr_read(csr)</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> csr_read(csr)                       \</span><br><span class="hljs-meta">(&#123;                                          \</span><br><span class="hljs-meta">    register uint64 __v;                    \</span><br><span class="hljs-meta">    asm volatile (<span class="hljs-string">&quot;csrr &quot;</span> <span class="hljs-string">&quot;%0, &quot;</span> #csr       \</span><br><span class="hljs-meta">                    : <span class="hljs-string">&quot;=r&quot;</span> (__v) :          \</span><br><span class="hljs-meta">                    : <span class="hljs-string">&quot;memory&quot;</span>);            \</span><br><span class="hljs-meta">    __v;                                    \</span><br><span class="hljs-meta">&#125;)</span><br></code></pre></td></tr></table></figure><p>模仿<code>csr_write(csr,val)</code>使用内联汇编进行宏的编写</p><p>实现效果</p><p><img src="https://typora-lqy.oss-cn-hangzhou.aliyuncs.com/image/image-20221012215909608.png"></p><h4 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h4><ol><li><p>函数调用分为6个阶段：</p><ul><li>将参数存到函数能访问到的位置</li><li>跳转到函数开始位置</li><li>获取函数需要的局部存储资源，按需要保存寄存器</li><li>执行函数中的指令</li><li>将返回值存储到调用者能访问到的位置，恢复寄存器，释放局部存储资源</li><li>返回调用函数的位置</li></ul><p>为了获取良好的性能，变量应该存放在内存而不是寄存器中。在函数调用中不保留某些寄存器存储的值，称为临时寄存器(caller saved register)，另一些寄存器则称为保存寄存器(callee saved register)。caller saved register为caller需要主动保存的寄存器，callee可以直接对其进行更改，在函数调用前后可能发生改变，所以为调用者保存寄存器。同理callee saved register在函数调用前后不发生改变，为被调用者保存寄存器。</p></li><li><p><img src="https://typora-lqy.oss-cn-hangzhou.aliyuncs.com/image/image-20221011203226755.png" alt="函数表"></p></li><li><p>test.c</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">puti</span>(<span class="hljs-built_in">csr_read</span>(sstatus));<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p><img src="https://typora-lqy.oss-cn-hangzhou.aliyuncs.com/image/image-20221011215221310.png"></p><p>其中sstatus寄存器各位含义如下</p><p><img src="https://typora-lqy.oss-cn-hangzhou.aliyuncs.com/image/image-20221013083129129.png" alt="sstatus寄存器布局"></p><table><thead><tr><th>字段名称</th><th>bit</th><th>含义</th><th>功能</th></tr></thead><tbody><tr><td>SSP</td><td>8</td><td>0：表示之前的mode为U-mode</td><td>记录hart在进入s-mode前的执行模式。当执行SRET指令，如果SPP为0，设置为用户模式，如果SPP为1，设置为超级用户模式并将SPP置0。</td></tr><tr><td>SIE</td><td>1</td><td>0：禁止中断       1：开启中断</td><td>表示在s-mode下禁止还是开启中断</td></tr><tr><td>SPIE</td><td>5</td><td>表示在trap中禁止S-mode中断</td><td>表示在trap发生在s-mode之前，是否启用s-mode中断。当trap在s-mode时，SPIE设置到SIE中，并且把SIE设置为0。当执行SRET指令后，SIE设置到SPIE中，然后将SPIE设置为0。</td></tr><tr><td>UBE</td><td>6</td><td>全称：Endianness  Control                 0：小端字节序     1：大端字节序</td><td>控制从U-mode进行显式内存访问的字节序，对指令访问没有影响。</td></tr></tbody></table></li><li><p>test.c</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">csr_write</span>(sscratch,<span class="hljs-number">111</span>);<br><span class="hljs-built_in">puti</span>(<span class="hljs-built_in">csr_read</span>(sscratch));<br></code></pre></td></tr></table></figure><p><img src="https://typora-lqy.oss-cn-hangzhou.aliyuncs.com/image/image-20221011215315041.png"></p></li><li><p>安装aarch64交叉编译工具链<img src="https://typora-lqy.oss-cn-hangzhou.aliyuncs.com/image/image-20221011235851303.png" alt="工具链安装"></p><p>使用默认配置<img src="https://typora-lqy.oss-cn-hangzhou.aliyuncs.com/image/image-20221011235907925.png"></p><p>编译直到获得sys.i文件<img src="https://typora-lqy.oss-cn-hangzhou.aliyuncs.com/image/image-20221012000107365.png"></p><p>使用vim查看文件<img src="https://typora-lqy.oss-cn-hangzhou.aliyuncs.com/image/image-20221012000343915.png"></p></li><li><p><code>ARM32</code></p><p>路径</p><p><code>linux\arch\arm\tools</code></p><p><img src="https://typora-lqy.oss-cn-hangzhou.aliyuncs.com/image/image-20221012001733054.png"></p><p><code>x86(32bit)</code></p><p>路径</p><p><code>linux\arch\x86\entry\syscalls</code></p><p><img src="https://typora-lqy.oss-cn-hangzhou.aliyuncs.com/image/image-20221012001433432.png"></p><p><code>x86(64bit)</code></p><p>路径</p><p><code>linux\arch\x86\entry\syscalls</code></p><p><img src="https://typora-lqy.oss-cn-hangzhou.aliyuncs.com/image/image-20221012001454428.png"></p><p><code>riscv(64bit)</code></p><p>路径</p><p><code>linux\arch\riscv\kernel\syscalls</code></p><p><img src="https://typora-lqy.oss-cn-hangzhou.aliyuncs.com/image/image-20221012002716441.png"></p></li><li><p>ELF文件是linux kernel编译出的带调试信息和符号表的可执行文件，在OS实验中为代码编译链接后生成的可供QEMU运行的RISCV64架构程序。ELF文件既可以参与程序的链接也可以用于执行。若用于链接，则将ELF文件视为<code>Section Headers Table</code>描述的<code>Section</code>的集合。若用于执行，则被视为<code>Program Headers Table</code>描述的段的集合。</p><p><code>readelf -a vmlinux</code></p><p><img src="https://typora-lqy.oss-cn-hangzhou.aliyuncs.com/image/image-20221012112706516.png"></p><p>打开2个terminal，其中一个make run整个repo</p><p>另一个terminal输入<code>ps au</code>查看现在运行的进程</p><p><img src="https://typora-lqy.oss-cn-hangzhou.aliyuncs.com/image/image-20221012112921578.png"></p><p>输入<code>cat /proc/PID/maps</code></p><p><img src="https://typora-lqy.oss-cn-hangzhou.aliyuncs.com/image/image-20221012113157989.png"></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="操作系统" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="os实验报告" scheme="http://example.com/tags/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    
  </entry>
  
  <entry>
    <title>oslab0_report</title>
    <link href="http://example.com/2023/07/08/oslab0-report/"/>
    <id>http://example.com/2023/07/08/oslab0-report/</id>
    <published>2023-07-08T06:45:05.000Z</published>
    <updated>2023-07-29T05:52:30.884Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Lab-0-实验报告"><a href="#Lab-0-实验报告" class="headerlink" title="Lab 0 实验报告"></a>Lab 0 实验报告</h2><h4 id="1搭建Docker环境"><a href="#1搭建Docker环境" class="headerlink" title="1搭建Docker环境"></a>1搭建Docker环境</h4><p>打开cmd，进入D盘<code>D:\oslab</code>目录</p><p>输入以下命令</p><p><code>docker load &lt; oslab.tar</code>生成镜像</p><p><img src="https://typora-lqy.oss-cn-hangzhou.aliyuncs.com/image/image-20220930190728703.png" alt="生成镜像"></p><p>输入<code>docker images</code>查看镜像</p><p><img src="https://typora-lqy.oss-cn-hangzhou.aliyuncs.com/image/image-20220930190755741.png" alt="查看镜像"></p><p>输入以下命令生成name为oslab的容器</p><p><code>docker run --name oslab -it oslab:2021 bash</code></p><p>提示符变为<code>#</code>说明成功进入容器</p><p><img src="https://typora-lqy.oss-cn-hangzhou.aliyuncs.com/image/image-20220930191111969.png" alt="进入容器"></p><p>输入<code>exit</code>退出容器，输入以下命令</p><p><code>docker ps</code></p><p><img src="https://typora-lqy.oss-cn-hangzhou.aliyuncs.com/image/image-20220930191202365.png" alt="查看运行中容器"></p><p>发现没有正在运行中的容器</p><p>再输入以下命令启动停止状态的容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker start oslab<br>docker ps<br></code></pre></td></tr></table></figure><p><img src="https://typora-lqy.oss-cn-hangzhou.aliyuncs.com/image/image-20220930191518070.png" alt="查看启动后容器"></p><p>输入<code>docker exec -it oslab bash</code>从终端连入docker容器</p><p>输入</p><p><code>docker run --name OSLAB -it -v C:\Users\LEGION:/have-fun-debugging oslab:2021 bash</code></p><p>新建一个容器将本地文件夹映射到新容器中的<code>have-fun-debugging</code>文件夹</p><p><img src="https://typora-lqy.oss-cn-hangzhou.aliyuncs.com/image/image-20221001182108936.png" alt="与windows文件系统建立映射"></p><h4 id="2获取Linux源码和已经编译好的文件系统"><a href="#2获取Linux源码和已经编译好的文件系统" class="headerlink" title="2获取Linux源码和已经编译好的文件系统"></a>2获取Linux源码和已经编译好的文件系统</h4><p>输入<code>git clone https://github.com/ZJU-SEC/os22fall-stu</code></p><p><img src="https://typora-lqy.oss-cn-hangzhou.aliyuncs.com/image/image-20221002125433963.png" alt="下载源码"></p><p><img src="https://typora-lqy.oss-cn-hangzhou.aliyuncs.com/image/image-20221002125500532.png"></p><h4 id="3编译Linux内核"><a href="#3编译Linux内核" class="headerlink" title="3编译Linux内核"></a>3编译Linux内核</h4><p><img src="https://typora-lqy.oss-cn-hangzhou.aliyuncs.com/image/image-20221002132043525.png"></p><p><img src="https://typora-lqy.oss-cn-hangzhou.aliyuncs.com/image/image-20221002132232029.png" alt="编译"></p><p>输入<code>make ARCH=riscv CROSS_COMPILE=riscv64-unknown-linux-gnu- -j8</code>编译内核</p><h4 id="4使用QEMU运行内核"><a href="#4使用QEMU运行内核" class="headerlink" title="4使用QEMU运行内核"></a>4使用QEMU运行内核</h4><p>在<code>linux</code>目录下输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">qemu-system-riscv64 -nographic -machine virt -kernel /debug/linux/arch/riscv/boot/Image -device virtio-blk-device,drive=hd0 -append <span class="hljs-string">&quot;root=/dev/vda ro console=ttyS0&quot;</span> -bios default -drive file=/os22fall-stu/src/lab0/rootfs.img,format=raw,<span class="hljs-built_in">id</span>=hd0<br></code></pre></td></tr></table></figure><p><img src="https://typora-lqy.oss-cn-hangzhou.aliyuncs.com/image/image-20221002152532546.png" alt="运行"></p><p><img src="https://typora-lqy.oss-cn-hangzhou.aliyuncs.com/image/image-20221002152602418.png"></p><h4 id="5使用GDB对内核进行调试"><a href="#5使用GDB对内核进行调试" class="headerlink" title="5使用GDB对内核进行调试"></a>5使用GDB对内核进行调试</h4><p>关闭前一步中打开的终端，在新的终端中使用QEMU运行内核</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">qemu-system-riscv64 -nographic -machine virt -kernel /debug/linux/arch/riscv/boot/Image -device virtio-blk-device,drive=hd0 -append <span class="hljs-string">&quot;root=/dev/vda ro console=ttyS0&quot;</span> -bios default -drive file=/os22fall-stu/src/lab0/rootfs.img,format=raw,<span class="hljs-built_in">id</span>=hd0 -S -s<br></code></pre></td></tr></table></figure><p><img src="https://typora-lqy.oss-cn-hangzhou.aliyuncs.com/image/image-20221002153246304.png"></p><p>因为添加了 <code>-S</code>所以暂停</p><p>打开一个新的终端进入<code>oslab</code>容器</p><p>输入<code>riscv64-unknown-linux-gnu-gdb /debug/linux/vmlinux</code></p><p><img src="https://typora-lqy.oss-cn-hangzhou.aliyuncs.com/image/image-20221002153554022.png"></p><p>连接QEMU</p><p><img src="https://typora-lqy.oss-cn-hangzhou.aliyuncs.com/image/image-20221002154033053.png"></p><p>在0x80000000和0x80200000设置断点</p><p><img src="https://typora-lqy.oss-cn-hangzhou.aliyuncs.com/image/image-20221002154804151.png" alt="设置断点"></p><p>运行至0x80200000的断点</p><p><img src="https://typora-lqy.oss-cn-hangzhou.aliyuncs.com/image/image-20221002154902119.png"></p><p><img src="https://typora-lqy.oss-cn-hangzhou.aliyuncs.com/image/image-20221002154915297.png"></p><p>输入<code>step instruction</code>执行单步指令</p><p><img src="https://typora-lqy.oss-cn-hangzhou.aliyuncs.com/image/image-20221002155054592.png" alt="单步调试"></p><p>通过<code>info</code>指令查看寄存器的值</p><p><img src="https://typora-lqy.oss-cn-hangzhou.aliyuncs.com/image/image-20221002155213087.png"></p><p>观察<code>addi gp,gp,-716</code>指令执行后<code>gp</code>寄存器值的变化</p><p><img src="https://typora-lqy.oss-cn-hangzhou.aliyuncs.com/image/image-20221002155431103.png"></p><p>退出</p><h4 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h4><p>5.<code>vmlinux</code>和<code>Image</code>同为<code>linux</code>的镜像，其中，<code>vmlinux</code>是对<code>linux</code>源码编译得到的<code>elf</code>格式的文件，文件较大，<code>Image</code>是<code>vmlinux</code>经过<code>objcopy</code>处理后的二进制文件，只包含内核代码的二进制数据。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="操作系统" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="os实验报告" scheme="http://example.com/tags/os%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
    
  </entry>
  
  <entry>
    <title>oslab5</title>
    <link href="http://example.com/2023/07/08/oslab5/"/>
    <id>http://example.com/2023/07/08/oslab5/</id>
    <published>2023-07-08T06:43:14.000Z</published>
    <updated>2023-07-29T05:52:30.887Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Lab-5-RV64-用户模式"><a href="#Lab-5-RV64-用户模式" class="headerlink" title="Lab 5: RV64 用户模式"></a>Lab 5: RV64 用户模式</h1><h2 id="1-实验目的"><a href="#1-实验目的" class="headerlink" title="1 实验目的"></a>1 实验目的</h2><ul><li>创建用户态进程，并设置 <code>sstatus</code> 来完成内核态转换至用户态。</li><li>正确设置用户进程的<strong>用户态栈</strong>和<strong>内核态栈</strong>， 并在异常处理时正确切换。</li><li>补充异常处理逻辑，完成指定的系统调用（ SYS_WRITE, SYS_GETPID ）功能。</li></ul><h2 id="2-实验环境"><a href="#2-实验环境" class="headerlink" title="2 实验环境"></a>2 实验环境</h2><ul><li>Docker in Lab0</li></ul><h2 id="3-背景知识"><a href="#3-背景知识" class="headerlink" title="3 背景知识"></a>3 背景知识</h2><h3 id="3-0-前言"><a href="#3-0-前言" class="headerlink" title="3.0 前言"></a>3.0 前言</h3><p>在 <a href="./lab4.md">lab4</a> 中，我们开启虚拟内存，这为进程间地址空间相互隔离打下了基础。之前的实验中我们只创建了内核线程，他们共用了地址空间 （共用一个<strong>内核页表</strong> <code>swapper_pg_dir</code> ）。在本次实验中我们将引入用户态进程。当启动用户模式应用程序时，内核将为该应用程序创建一个进程，为应用程序提供了专用虚拟地址空间等资源。因为应用程序的虚拟地址空间是私有的，所以一个应用程序无法更改属于另一个应用程序的数据。每个应用程序都是独立运行的，如果一个应用程序崩溃，其他应用程序和操作系统不会受到影响。同时，用户模式应用程序可访问的虚拟地址空间也受到限制，在用户模式下无法访问内核的虚拟地址，防止应用程序修改关键操作系统数据。当用户态程序需要访问关键资源的时候，可以通过系统调用来完成用户态程序与操作系统之间的互动。</p><h3 id="3-1-User-模式基础介绍"><a href="#3-1-User-模式基础介绍" class="headerlink" title="3.1 User 模式基础介绍"></a>3.1 User 模式基础介绍</h3><p>处理器具有两种不同的模式：用户模式和内核模式。在内核模式下，执行代码对底层硬件具有完整且不受限制的访问权限，它可以执行任何 CPU 指令并引用任何内存地址。在用户模式下，执行代码无法直接访问硬件，必须委托给系统提供的接口才能访问硬件或内存。处理器根据处理器上运行的代码类型在两种模式之间切换。应用程序以用户模式运行，而核心操作系统组件以内核模式运行。</p><h3 id="3-2-系统调用约定"><a href="#3-2-系统调用约定" class="headerlink" title="3.2 系统调用约定"></a>3.2 系统调用约定</h3><p>系统调用是用户态应用程序请求内核服务的一种方式。在 RISC-V 中，我们使用 <code>ecall</code> 指令进行系统调用。当执行这条指令时处理器会提升特权模式，跳转到异常处理函数处理这条系统调用。</p><p>Linux 中 RISC-V 相关的系统调用可以在 <code>include/uapi/asm-generic/unistd.h</code> 中找到，<a href="https://man7.org/linux/man-pages/man2/syscall.2.html"> syscall(2) </a>手册页上对RISC-V架构上的调用说明进行了总结，系统调用参数使用 a0 - a5 ，系统调用号使用 a7 ， 系统调用的返回值会被保存到 a0, a1 中。</p><h3 id="3-3-sstatus-SUM-PTE-U"><a href="#3-3-sstatus-SUM-PTE-U" class="headerlink" title="3.3 sstatus[SUM] PTE[U]"></a>3.3 sstatus[SUM] PTE[U]</h3><p>当页表项 PTE[U] 置 0 时，该页表项对应的内存页为内核页，运行在 U-Mode 下的代码<strong>无法访问</strong>。当页表项 PTE[U] 置 1 时，该页表项对应的内存页为用户页，运行在 S-Mode 下的代码<strong>无法访问</strong>。如果想让 S 特权级下的程序能够访问用户页，需要对 sstatus[SUM] 位置 1 。但是无论什么样的情况下，用户页中的指令对于 S-Mode 而言都是<strong>无法执行</strong>的。 </p><h3 id="3-4-用户态栈与内核态栈"><a href="#3-4-用户态栈与内核态栈" class="headerlink" title="3.4 用户态栈与内核态栈"></a>3.4 用户态栈与内核态栈</h3><p>当用户态程序在用户态运行时，其使用的栈为<strong>用户态栈</strong>，当调用 SYSCALL时候，陷入内核处理时使用的栈为<strong>内核态栈</strong>，因此需要区分用户态栈和内核态栈，并在异常处理的过程中需要对栈进行切换。</p><h2 id="4-实验步骤"><a href="#4-实验步骤" class="headerlink" title="4 实验步骤"></a>4 实验步骤</h2><h3 id="4-1-准备工程"><a href="#4-1-准备工程" class="headerlink" title="4.1 准备工程"></a>4.1 准备工程</h3><ul><li>此次实验基于 lab4 同学所实现的代码进行。</li><li>需要修改 <code>vmlinux.lds.S</code>，将用户态程序 <code>uapp</code> 加载至 <code>.data</code> 段。按如下修改：</li></ul><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs haskell">...<br><br>.<span class="hljs-class"><span class="hljs-keyword">data</span> : <span class="hljs-type">ALIGN</span>(0<span class="hljs-title">x1000</span>)&#123;</span><br><span class="hljs-class">        <span class="hljs-title">_sdata</span> = .;</span><br><span class="hljs-class"></span><br><span class="hljs-class">        *(.<span class="hljs-title">sdata</span> .<span class="hljs-title">sdata</span>*)</span><br><span class="hljs-class">        *(.<span class="hljs-title">data</span> .<span class="hljs-title">data</span>.*)</span><br><span class="hljs-class"></span><br><span class="hljs-class">        <span class="hljs-title">_edata</span> = .;</span><br><span class="hljs-class">        </span><br><span class="hljs-class">        . = <span class="hljs-type">ALIGN(0x1000)</span>;</span><br><span class="hljs-class">        <span class="hljs-title">uapp_start</span> = .;</span><br><span class="hljs-class">        *(.<span class="hljs-title">uapp</span> .<span class="hljs-title">uapp</span>*)</span><br><span class="hljs-class">        <span class="hljs-title">uapp_end</span> = .;</span><br><span class="hljs-class">        . = <span class="hljs-type">ALIGN(0x1000)</span>;</span><br><span class="hljs-class"></span><br><span class="hljs-class">    &#125; &gt;ramv <span class="hljs-type">AT</span>&gt;ram</span><br><br>...<br></code></pre></td></tr></table></figure><ul><li>需要修改 <code>defs.h</code>，在 <code>defs.h</code> <code>添加</code> 如下内容：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> USER_START (0x0000000000000000) <span class="hljs-comment">// user space start virtual address</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> USER_END   (0x0000004000000000) <span class="hljs-comment">// user space end virtual address</span></span><br></code></pre></td></tr></table></figure><ul><li>从 <code>repo</code> 同步以下文件夹: <code>user</code>， <code>Makefile</code>。并按照以下步骤将这些文件正确放置。</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs stylus">.<br>├── arch<br>│   └── riscv<br>│       └── Makefile<br>└── user<br>    ├── Makefile<br>    ├── getpid<span class="hljs-selector-class">.c</span><br>    ├── link<span class="hljs-selector-class">.lds</span><br>    ├── printf<span class="hljs-selector-class">.c</span><br>    ├── start<span class="hljs-selector-class">.S</span><br>    ├── stddef<span class="hljs-selector-class">.h</span><br>    ├── stdio<span class="hljs-selector-class">.h</span><br>    ├── syscall<span class="hljs-selector-class">.h</span><br>    └── uapp.S<br></code></pre></td></tr></table></figure><ul><li>修改<strong>根目录</strong>下的 Makefile, 将 <code>user</code> 纳入工程管理。</li><li>在根目录下 <code>make</code> 会生成 <code>user/uapp.o</code> <code>user/uapp.elf</code> <code>user/uapp.bin</code>。 通过 <code>objdump</code> 我们可以看到 uapp 使用 ecall 来调用 SYSCALL (在 U-Mode 下使用 ecall 会触发environment-call-from-U-mode异常)。从而将控制权交给处在 S-Mode 的 OS， 由内核来处理相关异常。</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-number">0000000000000004</span> &lt;getpid&gt;:                                                                       <br><span class="hljs-symbol">  4:</span>   fe010113             <span class="hljs-keyword">addi </span>   <span class="hljs-built_in">sp</span>,<span class="hljs-built_in">sp</span>,-<span class="hljs-number">32</span>                                                <br><span class="hljs-symbol">  8:</span>   <span class="hljs-number">00813</span>c23             sd      <span class="hljs-built_in">s0</span>,<span class="hljs-number">24</span>(<span class="hljs-built_in">sp</span>)                                                <br>  c:   <span class="hljs-number">02010413</span>             <span class="hljs-keyword">addi </span>   <span class="hljs-built_in">s0</span>,<span class="hljs-built_in">sp</span>,<span class="hljs-number">32</span>                                                 <br><span class="hljs-symbol"> 10:</span>   fe843783             ld      <span class="hljs-built_in">a5</span>,-<span class="hljs-number">24</span>(<span class="hljs-built_in">s0</span>)                                               <br><span class="hljs-symbol"> 14:</span>   <span class="hljs-number">0</span>ac00893             li      <span class="hljs-built_in">a7</span>,<span class="hljs-number">172</span>                                                   <br><span class="hljs-symbol"> 18:</span>   <span class="hljs-number">00000073</span>             ecall                               &lt;- SYS_GETPID                        <br>...<br><br><span class="hljs-number">00000000000000</span>d8 &lt;vprintfmt&gt;:<br>...<br><span class="hljs-number">60</span>c:<span class="hljs-number">00070513</span>            mv<span class="hljs-built_in">a0</span>,<span class="hljs-built_in">a4</span><br><span class="hljs-number">610</span>:<span class="hljs-number">00068593</span>            mv<span class="hljs-built_in">a1</span>,<span class="hljs-built_in">a3</span><br><span class="hljs-number">614</span>:<span class="hljs-number">00060613</span>            mv<span class="hljs-built_in">a2</span>,<span class="hljs-built_in">a2</span><br><span class="hljs-number">618</span>:<span class="hljs-number">00000073</span>            ecall                               &lt;- SYS_WRITE<br>...<br></code></pre></td></tr></table></figure><h3 id="4-2-创建用户态进程"><a href="#4-2-创建用户态进程" class="headerlink" title="4.2 创建用户态进程"></a>4.2 创建用户态进程</h3><ul><li>本次实验只需要创建 4 个用户态进程，修改 <code>proc.h</code> 中的 <code>NR_TASKS</code> 即可。</li><li>由于创建用户态进程要对 <code>sepc</code> <code>sstatus</code> <code>sscratch</code> 做设置，我们将其加入 <code>thread_struct</code> 中。</li><li>由于多个用户态进程需要保证相对隔离，因此不可以共用页表。我们为每个用户态进程都创建一个页表。修改 <code>task_struct</code> 如下。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// proc.h </span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>* <span class="hljs-type">pagetable_t</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread_struct</span> &#123;</span><br>    <span class="hljs-type">uint64_t</span> ra;<br>    <span class="hljs-type">uint64_t</span> sp;                     <br>    <span class="hljs-type">uint64_t</span> s[<span class="hljs-number">12</span>];<br><br>    <span class="hljs-type">uint64_t</span> sepc, sstatus, sscratch; <br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span> &#123;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread_info</span>* <span class="hljs-title">thread_info</span>;</span><br>    <span class="hljs-type">uint64_t</span> state;<br>    <span class="hljs-type">uint64_t</span> counter;<br>    <span class="hljs-type">uint64_t</span> priority;<br>    <span class="hljs-type">uint64_t</span> pid;<br><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread_struct</span> <span class="hljs-title">thread</span>;</span><br><br>    <span class="hljs-type">pagetable_t</span> pgd;<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li>修改 task_init<ul><li>对每个用户态进程，其拥有两个 stack： <code>U-Mode Stack</code> 以及 <code>S-Mode Stack</code>， 其中 <code>S-Mode Stack</code> 在 <code>lab3</code> 中我们已经设置好了。我们可以通过 <code>kalloc</code> 接口申请一个空的页面来作为 <code>U-Mode Stack</code>。</li><li>为每个用户态进程创建自己的页表 并将 <code>uapp</code> 所在页面，以及 <code>U-Mode Stack</code> 做相应的映射，同时为了避免 <code>U-Mode</code> 和 <code>S-Mode</code> 切换的时候切换页表，我们也将内核页表 （ <code>swapper_pg_dir</code> ） 复制到每个进程的页表中。</li><li>对每个用户态进程我们需要将 <code>sepc</code> 修改为 <code>USER_START</code>， 设置 <code>sstatus</code> 中的 <code>SPP</code> （ 使得 sret 返回至 U-Mode ）， <code>SPIE</code> （ sret 之后开启中断 ）， <code>SUM</code> （ S-Mode 可以访问 User 页面 ）， <code>sscratch</code> 设置为 <code>U-Mode</code> 的 sp，其值为 <code>USER_END</code> （即  <code>U-Mode Stack</code> 被放置在 <code>user space</code> 的最后一个页面）。</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp">               PHY_START                                                                PHY_END<br>                        uapp_start   uapp_end<br>                  │         │            │                                                 │<br>                  ▼         ▼            ▼                                                 ▼<br>      ┌───────────┬─────────┬────────────┬─────────────────────────────────────────────────┐<br>PA    │           │         │    uapp    │                                                 │<br>      └───────────┴─────────┴────────────┴─────────────────────────────────────────────────┘<br>                            ▲            ▲<br>      ┌─────────────────────┘            │<br>      │                                  │<br>      │            ┌─────────────────────┘<br>      │            │<br>      │            │<br>      ├────────────┼───────────────────────────────────────────────────────────────────┬────────────┐<br>VA    │    UAPP    │                                                                   │u mode stack│<br>      └────────────┴───────────────────────────────────────────────────────────────────┴────────────┘<br>      ▲                                                                                             ▲<br>      │                                                                                             │<br><br>  USER_START                                                                                    USER_END<br><br></code></pre></td></tr></table></figure><ul><li>修改 __switch_to， 需要加入 保存&#x2F;恢复 <code>sepc</code> <code>sstatus</code> <code>sscratch</code> 以及 切换页表的逻辑。</li></ul><h3 id="4-3-修改中断入口-x2F-返回逻辑-trap-以及中断处理函数-（-trap-handler-）"><a href="#4-3-修改中断入口-x2F-返回逻辑-trap-以及中断处理函数-（-trap-handler-）" class="headerlink" title="4.3 修改中断入口&#x2F;返回逻辑 ( _trap ) 以及中断处理函数 （ trap_handler ）"></a>4.3 修改中断入口&#x2F;返回逻辑 ( _trap ) 以及中断处理函数 （ trap_handler ）</h3><ul><li><p>与 ARM 架构不同的是，RISC-V 中只有一个栈指针寄存器( sp )，因此需要我们来完成用户栈与内核栈的切换。</p></li><li><p>由于我们的用户态进程运行在 <code>U-Mode</code> 下， 使用的运行栈也是 <code>U-Mode Stack</code>， 因此当触发异常时， 我们首先要对栈进行切换 （ <code>U-Mode Stack</code> -&gt; <code>S-Mode Stack</code> ）。同理 让我们完成了异常处理， 从 <code>S-Mode</code> 返回至 <code>U-Mode</code>， 也需要进行栈切换 （ <code>S-Mode Stack</code> -&gt; <code>U-Mode Stack</code> ）。</p></li><li><p>修改 <code>__dummy</code>。在 <strong>4.2</strong> 中 我们初始化时， <code>thread_struct.sp</code> 保存了 <code>S-Mode sp</code>， <code>thread_struct.sscratch</code> 保存了 <code>U-Mode sp</code>， 因此在 <code>S-Mode -&gt; U-&gt;Mode</code> 的时候，我们只需要交换对应的寄存器的值即可。</p></li><li><p>修改 <code>_trap</code> 。同理 在 <code>_trap</code> 的首尾我们都需要做类似的操作。<strong>注意如果是 内核线程( 没有 U-Mode Stack ) 触发了异常，则不需要进行切换。（内核线程的 sp 永远指向的 S-Mode Stack， sscratch 为 0）</strong></p></li><li><p><code>uapp</code> 使用 <code>ecall</code> 会产生 <code>ECALL_FROM_U_MODE</code> <strong>exception</strong>。因此我们需要在 <code>trap_handler</code> 里面进行捕获。修改 <code>trap_handler</code> 如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">trap_handler</span><span class="hljs-params">(<span class="hljs-type">uint64_t</span> scause, <span class="hljs-type">uint64_t</span> sepc, <span class="hljs-keyword">struct</span> pt_regs *regs)</span> &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>这里需要解释新增加的第三个参数 <code>regs</code>， 在 _trap 中我们将寄存器的内容<strong>连续</strong>的保存在 S-Mode Stack上， 因此我们可以将这一段看做一个叫做 <code>pt_regs</code>的结构体。我们可以从这个结构体中取到相应的寄存器的值（ 比如 syscall 中我们需要从 a0 ~ a7 寄存器中取到参数 ）。 示例如下图：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs llvm">   High Addr ───►  ┌─────────────┐<br>                   │   sstatus   │<br>                   │             │<br>                   │     sepc    │<br>                   │             │<br>                   │     <span class="hljs-keyword">x</span><span class="hljs-number">31</span>     │<br>                   │             │<br>                   │      .      │<br>                   │      .      │<br>                   │      .      │<br>                   │             │<br>                   │     <span class="hljs-keyword">x</span><span class="hljs-number">1</span>      │<br>                   │             │<br>                   │     <span class="hljs-keyword">x</span><span class="hljs-number">0</span>      │<br>sp (pt_regs)  ──►  ├─────────────┤<br>                   │             │<br>                   │             │<br>                   │             │<br>                   │             │<br>                   │             │<br>                   │             │<br>                   │             │<br>                   │             │<br>                   │             │<br>   Low  Addr ───►  └─────────────┘<br>  <br></code></pre></td></tr></table></figure><p>请同学自己补充 <code>struct pt_regs</code>的定义， 以及在 <code>trap_hanlder</code> 中补充处理 SYSCALL 的逻辑。</p></li></ul><h3 id="4-4-添加系统调用"><a href="#4-4-添加系统调用" class="headerlink" title="4.4 添加系统调用"></a>4.4 添加系统调用</h3><ul><li>本次实验要求的系统调用函数原型以及具体功能如下：<ul><li>64 号系统调用 <code>sys_write(unsigned int fd, const char* buf, size_t count)</code> 该调用将用户态传递的字符串打印到屏幕上，此处fd为标准输出（1），buf为用户需要打印的起始地址，count为字符串长度，返回打印的字符数。( 具体见 user&#x2F;printf.c )</li><li>172 号系统调用 <code>sys_getpid()</code> 该调用从current中获取当前的pid放入a0中返回，无参数。（ 具体见 user&#x2F;getpid.c ）</li></ul></li><li>增加 <code>syscall.c</code> <code>syscall.h</code> 文件， 并在其中实现 <code>getpid</code> 以及 <code>write</code> 逻辑。</li><li>系统调用的返回参数放置在 <code>a0</code> 中 (不可以直接修改寄存器， 应该修改 regs 中保存的内容)。</li><li>针对系统调用这一类异常， 我们需要手动将 <code>sepc + 4</code> （ <code>sepc</code> 记录的是触发异常的指令地址， 由于系统调用这类异常处理完成之后， 我们应该继续执行后续的指令，因此需要我们手动修改 <code>spec</code> 的地址，使得 <code>sret</code> 之后 程序继续执行）。</li></ul><h3 id="4-5-修改-head-S-以及-start-kernel"><a href="#4-5-修改-head-S-以及-start-kernel" class="headerlink" title="4.5 修改 head.S 以及 start_kernel"></a>4.5 修改 head.S 以及 start_kernel</h3><ul><li>之前 lab 中， 在 OS boot 之后，我们需要等待一个时间片，才会进行调度。我们现在更改为 OS boot 完成之后立即调度 uapp 运行。</li><li>在 start_kernel 中调用 schedule() 注意放置在 test() 之前。</li><li>将 head.S 中 enable interrupt sstatus.SIE 逻辑注释，确保 schedule 过程不受中断影响。</li></ul><h3 id="4-6-编译及测试"><a href="#4-6-编译及测试" class="headerlink" title="4.6 编译及测试"></a>4.6 编译及测试</h3><ul><li><p>由于加入了一些新的 .c 文件，可能需要修改一些Makefile文件，请同学自己尝试修改，使项目可以编译并运行。</p></li><li><p>输出示例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs bash">OpenSBI v0.9<br>     ____                    _____ ____ _____<br>    / __ \                  / ____|  _ \_   _|<br>    | |  | |_ __   ___ _ __ | (___ | |_) || |<br>    | |  | | <span class="hljs-string">&#x27;_ \ / _ \ &#x27;</span>_ \ \___ \|  _ &lt; | |<br>    | |__| | |_) |  __/ | | |____) | |_) || |_<br>    \____/| .__/ \___|_| |_|_____/|____/_____|<br>        | |<br>        |_|<br><br>    ...<br><br>    Boot HART MIDELEG         : 0x0000000000000222<br>    Boot HART MEDELEG         : 0x000000000000b109<br><br>    ...mm_init <span class="hljs-keyword">done</span>!<br>    ...proc_init <span class="hljs-keyword">done</span>!<br>    [S-MODE] Hello RISC-V<br><br>    [U-MODE] pid: 4, sp is 0000003fffffffe0<br>    [U-MODE] pid: 3, sp is 0000003fffffffe0<br>    [U-MODE] pid: 2, sp is 0000003fffffffe0<br>    [U-MODE] pid: 1, sp is 0000003fffffffe0<br><br>    [U-MODE] pid: 4, sp is 0000003fffffffe0<br>    [U-MODE] pid: 3, sp is 0000003fffffffe0<br>    [U-MODE] pid: 2, sp is 0000003fffffffe0<br>    [U-MODE] pid: 1, sp is 0000003fffffffe0<br><br>    [U-MODE] pid: 4, sp is 0000003fffffffe0<br>    [U-MODE] pid: 3, sp is 0000003fffffffe0<br>    [U-MODE] pid: 2, sp is 0000003fffffffe0<br>    [U-MODE] pid: 1, sp is 0000003fffffffe0<br><br>    [U-MODE] pid: 4, sp is 0000003fffffffe0<br>    [U-MODE] pid: 3, sp is 0000003fffffffe0<br>    [U-MODE] pid: 2, sp is 0000003fffffffe0<br>    [U-MODE] pid: 1, sp is 0000003fffffffe0<br>    ...<br><br></code></pre></td></tr></table></figure></li></ul><h2 id="作业提交"><a href="#作业提交" class="headerlink" title="作业提交"></a>作业提交</h2><p>同学需要提交实验报告以及整个工程代码。在提交前请使用 <code>make clean</code> 清除所有构建产物。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="操作系统" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="os实验文档" scheme="http://example.com/tags/os%E5%AE%9E%E9%AA%8C%E6%96%87%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title>oslab4</title>
    <link href="http://example.com/2023/07/08/oslab4/"/>
    <id>http://example.com/2023/07/08/oslab4/</id>
    <published>2023-07-08T06:43:11.000Z</published>
    <updated>2023-07-29T05:52:30.886Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Lab-4-RV64-虚拟内存管理"><a href="#Lab-4-RV64-虚拟内存管理" class="headerlink" title="Lab 4: RV64 虚拟内存管理"></a>Lab 4: RV64 虚拟内存管理</h1><h2 id="1-实验目的"><a href="#1-实验目的" class="headerlink" title="1 实验目的"></a>1 实验目的</h2><ul><li>学习虚拟内存的相关知识，实现物理地址到虚拟地址的切换。</li><li>了解 RISC-V 架构中 SV39 分页模式，实现虚拟地址到物理地址的映射，并对不同的段进行相应的权限设置。</li></ul><h2 id="2-实验环境"><a href="#2-实验环境" class="headerlink" title="2 实验环境"></a>2 实验环境</h2><ul><li>Environment in previous labs</li></ul><h2 id="3-背景知识"><a href="#3-背景知识" class="headerlink" title="3 背景知识"></a>3 背景知识</h2><h3 id="3-0-前言"><a href="#3-0-前言" class="headerlink" title="3.0 前言"></a>3.0 前言</h3><p>在 lab3 中我们赋予了 OS 对多个线程调度以及并发执行的能力，由于目前这些线程都是内核线程，因此他们可以共享运行空间，即运行不同线程对空间的修改是相互可见的。但是如果我们需要线程相互<strong>隔离</strong>，以及在多线程的情况下更加<strong>高效</strong>的使用内存，就必须引入<code>虚拟内存</code>这个概念。</p><p>虚拟内存可以为正在运行的进程提供独立的内存空间，制造一种每个进程的内存都是独立的假象。同时虚拟内存到物理内存的映射也包含了对内存的访问权限，方便 Kernel 完成权限检查。</p><p>在本次实验中，我们需要关注 OS 如何<strong>开启虚拟地址</strong>以及通过设置页表来实现<strong>地址映射</strong>和<strong>权限控制</strong>。</p><h3 id="3-1-Kernel-的虚拟内存布局"><a href="#3-1-Kernel-的虚拟内存布局" class="headerlink" title="3.1 Kernel 的虚拟内存布局"></a>3.1 Kernel 的虚拟内存布局</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">start_address           end_address<br>    <span class="hljs-number">0</span>x0                 <span class="hljs-number">0</span>x3fffffffff<br>     │                       │<br>┌────┘                 ┌─────┘<br>↓        <span class="hljs-number">256</span>G          ↓                                <br>┌───────────────────────┬──────────┬────────────────┐<br>│      <span class="hljs-keyword">User</span> <span class="hljs-title">Space</span>       │    ...   │  Kernel Space  │<br>└───────────────────────┴──────────┴────────────────┘<br>                                    ↑    <span class="hljs-number">256</span>G      ↑<br>                      ┌─────────────┘              │ <br>                      │                            │<br>              <span class="hljs-number">0</span>xffffffc000000000          <span class="hljs-number">0</span>xffffffffffffffff<br>                start_address                 end_address<br></code></pre></td></tr></table></figure><p>通过上图我们可以看到 RV64 将 <code>0x0000004000000000</code> 以下的虚拟空间作为 <code>user space</code>。将 <code>0xffffffc000000000</code> 及以上的虚拟空间作为 <code>kernel space</code>。由于我们还未引入用户态程序，目前我们只需要关注 <code>kernel space</code>。</p><p>具体的虚拟内存布局可以<a href="https://elixir.bootlin.com/linux/v5.15/source/Documentation/riscv/vm-layout.rst">参考这里</a>。</p><blockquote><p>在 <code>RISC-V Linux Kernel Space</code> 中有一段区域被称为 <code>direct mapping area</code>，为了方便 kernel 可以高效率的访问 RAM，kernel 会预先把所有物理内存都映射至这一块区域 ( PA + OFFSET &#x3D;&#x3D; VA )， 这种映射也被称为 <code>linear mapping</code>。在 RISC-V Linux Kernel 中这一段区域为 <code>0xffffffe000000000 ~ 0xffffffff00000000</code>, 共 124 GB 。</p></blockquote><h3 id="3-2-RISC-V-Virtual-Memory-System-Sv39"><a href="#3-2-RISC-V-Virtual-Memory-System-Sv39" class="headerlink" title="3.2 RISC-V Virtual-Memory System (Sv39)"></a>3.2 RISC-V Virtual-Memory System (Sv39)</h3><h4 id="3-2-1-satp-Register（Supervisor-Address-Translation-and-Protection-Register）"><a href="#3-2-1-satp-Register（Supervisor-Address-Translation-and-Protection-Register）" class="headerlink" title="3.2.1 satp Register（Supervisor Address Translation and Protection Register）"></a>3.2.1 <code>satp</code> Register（Supervisor Address Translation and Protection Register）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-number">63</span>      <span class="hljs-number">60</span> <span class="hljs-number">59</span>                  <span class="hljs-number">44</span> <span class="hljs-number">43</span>                                <span class="hljs-number">0</span><br> ---------------------------------------------------------------------<br>|   MODE   |         ASID         |                PPN                |<br> ---------------------------------------------------------------------<br></code></pre></td></tr></table></figure><ul><li>MODE 字段的取值如下图：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c">                         RV <span class="hljs-number">64</span><br> ----------------------------------------------------------<br>|  Value  |  Name  |  Description                          |<br>|----------------------------------------------------------|<br>|    <span class="hljs-number">0</span>    | Bare   | No translation or protection          |<br>|  <span class="hljs-number">1</span> - <span class="hljs-number">7</span>  | ---    | Reserved <span class="hljs-keyword">for</span> standard use             |<br>|    <span class="hljs-number">8</span>    | Sv39   | Page-based <span class="hljs-number">39</span> bit virtual addressing  | &lt;-- 我们使用的mode<br>|    <span class="hljs-number">9</span>    | Sv48   | Page-based <span class="hljs-number">48</span> bit virtual addressing  |<br>|    <span class="hljs-number">10</span>   | Sv57   | Page-based <span class="hljs-number">57</span> bit virtual addressing  |<br>|    <span class="hljs-number">11</span>   | Sv64   | Page-based <span class="hljs-number">64</span> bit virtual addressing  |<br>| <span class="hljs-number">12</span> - <span class="hljs-number">13</span> | ---    | Reserved <span class="hljs-keyword">for</span> standard use             |<br>| <span class="hljs-number">14</span> - <span class="hljs-number">15</span> | ---    | Reserved <span class="hljs-keyword">for</span> standard use             |<br> -----------------------------------------------------------<br></code></pre></td></tr></table></figure><ul><li>ASID ( Address Space Identifier ) ： 此次实验中直接置 0 即可。</li><li>PPN ( Physical Page Number ) ：顶级页表的物理页号。我们的物理页的大小为 4KB， PA &gt;&gt; 12 &#x3D;&#x3D; PPN。</li><li>具体介绍请阅读 <a href="https://www.five-embeddev.com/riscv-isa-manual/latest/supervisor.html#sec:satp">RISC-V Privileged Spec 4.1.10</a> 。</li></ul><h4 id="3-2-2-RISC-V-Sv39-Virtual-Address-and-Physical-Address"><a href="#3-2-2-RISC-V-Sv39-Virtual-Address-and-Physical-Address" class="headerlink" title="3.2.2 RISC-V Sv39 Virtual Address and Physical Address"></a>3.2.2 RISC-V Sv39 Virtual Address and Physical Address</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-number">38</span>        <span class="hljs-number">30</span> <span class="hljs-number">29</span>        <span class="hljs-number">21</span> <span class="hljs-number">20</span>        <span class="hljs-number">12</span> <span class="hljs-number">11</span>                           <span class="hljs-number">0</span><br> ---------------------------------------------------------------------<br>|   VPN[<span class="hljs-number">2</span>]   |   VPN[<span class="hljs-number">1</span>]   |   VPN[<span class="hljs-number">0</span>]   |          page offset         |<br> ---------------------------------------------------------------------<br>                        Sv39 virtual address<br><br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-number">55</span>                <span class="hljs-number">30</span> <span class="hljs-number">29</span>        <span class="hljs-number">21</span> <span class="hljs-number">20</span>        <span class="hljs-number">12</span> <span class="hljs-number">11</span>                           <span class="hljs-number">0</span><br> -----------------------------------------------------------------------------<br>|       PPN[<span class="hljs-number">2</span>]       |   PPN[<span class="hljs-number">1</span>]   |   PPN[<span class="hljs-number">0</span>]   |          page offset         |<br> -----------------------------------------------------------------------------<br>                            Sv39 physical address<br><br></code></pre></td></tr></table></figure><ul><li>Sv39 模式定义物理地址有 56 位，虚拟地址有 64 位。但是，虚拟地址的 64 位只有低 39 位有效。通过虚拟内存布局图我们可以发现，其 63-39 位为 0 时代表 user space address， 为 1 时 代表 kernel space address。</li><li>Sv39 支持三级页表结构，VPN[2-0](Virtual Page Number)分别代表每级页表的<code>虚拟页号</code>，PPN[2-0](Physical Page Number)分别代表每级页表的<code>物理页号</code>。物理地址和虚拟地址的低12位表示页内偏移（page offset）。</li><li>具体介绍请阅读 <a href="https://www.five-embeddev.com/riscv-isa-manual/latest/supervisor.html#sec:sv39">RISC-V Privileged Spec 4.4.1</a> 。</li></ul><h4 id="3-2-3-RISC-V-Sv39-Page-Table-Entry"><a href="#3-2-3-RISC-V-Sv39-Page-Table-Entry" class="headerlink" title="3.2.3 RISC-V Sv39 Page Table Entry"></a>3.2.3 RISC-V Sv39 Page Table Entry</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-number">63</span>      <span class="hljs-number">54</span> <span class="hljs-number">53</span>        <span class="hljs-number">28</span> <span class="hljs-number">27</span>        <span class="hljs-number">19</span> <span class="hljs-number">18</span>        <span class="hljs-number">10</span> <span class="hljs-number">9</span>   <span class="hljs-number">8</span> <span class="hljs-number">7</span> <span class="hljs-number">6</span> <span class="hljs-number">5</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br> -----------------------------------------------------------------------<br>| Reserved |   PPN[<span class="hljs-number">2</span>]   |   PPN[<span class="hljs-number">1</span>]   |   PPN[<span class="hljs-number">0</span>]   | RSW |D|A|G|U|X|W|R|V|<br> -----------------------------------------------------------------------<br>                                                     |   | | | | | | | |<br>                                                     |   | | | | | | | `---- V - Valid<br>                                                     |   | | | | | | `------ R - Readable<br>                                                     |   | | | | | `-------- W - Writable<br>                                                     |   | | | | `---------- X - Executable<br>                                                     |   | | | `------------ U - User<br>                                                     |   | | `-------------- G - Global<br>                                                     |   | `---------------- A - Accessed<br>                                                     |   `------------------ D - Dirty (<span class="hljs-number">0</span> in page directory)<br>                                                     `---------------------- Reserved <span class="hljs-keyword">for</span> supervisor software<br></code></pre></td></tr></table></figure><ul><li>0 ～ 9 bit: protection bits<ul><li>V : 有效位，当 V &#x3D; 0, 访问该 PTE 会产生 Pagefault。</li><li>R : R &#x3D; 1 该页可读。</li><li>W : W &#x3D; 1 该页可写。</li><li>X : X &#x3D; 1 该页可执行。</li><li>U , G , A , D , RSW 本次实验中设置为 0 即可。</li></ul></li><li>具体介绍请阅读 <a href="https://www.five-embeddev.com/riscv-isa-manual/latest/supervisor.html#sec:sv39">RISC-V Privileged Spec 4.4.1</a></li></ul><h4 id="3-2-4-RISC-V-Address-Translation"><a href="#3-2-4-RISC-V-Address-Translation" class="headerlink" title="3.2.4 RISC-V Address Translation"></a>3.2.4 RISC-V Address Translation</h4><p>虚拟地址转化为物理地址流程图如下，具体描述见 <a href="https://www.five-embeddev.com/riscv-isa-manual/latest/supervisor.html#sv32algorithm">RISC-V Privileged Spec 4.3.2</a> :</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs text">                                Virtual Address                                     Physical Address<br><br>                          9             9            9              12          55        12 11       0<br>   ┌────────────────┬────────────┬────────────┬─────────────┬────────────────┐ ┌────────────┬──────────┐<br>   │                │   VPN[2]   │   VPN[1]   │   VPN[0]    │     OFFSET     │ │     PPN    │  OFFSET  │<br>   └────────────────┴────┬───────┴─────┬──────┴──────┬──────┴───────┬────────┘ └────────────┴──────────┘<br>                         │             │             │              │                 ▲          ▲<br>                         │             │             │              │                 │          │<br>                         │             │             │              │                 │          │<br>┌────────────────────────┘             │             │              │                 │          │<br>│                                      │             │              │                 │          │<br>│                                      │             │              └─────────────────┼──────────┘<br>│    ┌─────────────────┐               │             │                                │<br>│511 │                 │  ┌────────────┘             │                                │<br>│    │                 │  │                          │                                │<br>│    │                 │  │     ┌─────────────────┐  │                                │<br>│    │                 │  │ 511 │                 │  │                                │<br>│    │                 │  │     │                 │  │                                │<br>│    │                 │  │     │                 │  │     ┌─────────────────┐        │<br>│    │   44       10   │  │     │                 │  │ 511 │                 │        │<br>│    ├────────┬────────┤  │     │                 │  │     │                 │        │<br>└───►│   PPN  │  flags │  │     │                 │  │     │                 │        │<br>     ├────┬───┴────────┤  │     │   44       10   │  │     │                 │        │<br>     │    │            │  │     ├────────┬────────┤  │     │                 │        │<br>     │    │            │  └────►│   PPN  │  flags │  │     │                 │        │<br>     │    │            │        ├────┬───┴────────┤  │     │   44       10   │        │<br>     │    │            │        │    │            │  │     ├────────┬────────┤        │<br>   1 │    │            │        │    │            │  └────►│   PPN  │  flags │        │<br>     │    │            │        │    │            │        ├────┬───┴────────┤        │<br>   0 │    │            │        │    │            │        │    │            │        │<br>     └────┼────────────┘      1 │    │            │        │    │            │        │<br>     ▲    │                     │    │            │        │    └────────────┼────────┘<br>     │    │                   0 │    │            │        │                 │<br>     │    └────────────────────►└────┼────────────┘      1 │                 │<br>     │                               │                     │                 │<br> ┌───┴────┐                          │                   0 │                 │<br> │  satp  │                          └────────────────────►└─────────────────┘<br> └────────┘<br></code></pre></td></tr></table></figure><h2 id="4-实验步骤"><a href="#4-实验步骤" class="headerlink" title="4 实验步骤"></a>4 实验步骤</h2><h3 id="4-1-准备工程"><a href="#4-1-准备工程" class="headerlink" title="4.1 准备工程"></a>4.1 准备工程</h3><ul><li><p>此次实验基于 lab3 同学所实现的代码进行。</p></li><li><p>需要修改 <code>defs.h</code>, 在 <code>defs.h</code> <strong>添加</strong>如下内容：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> OPENSBI_SIZE (0x200000)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> VM_START (0xffffffe000000000)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> VM_END   (0xffffffff00000000)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> VM_SIZE  (VM_END - VM_START)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PA2VA_OFFSET (VM_START - PHY_START)</span><br></code></pre></td></tr></table></figure></li><li><p>从 <code>repo</code> 同步以下代码: <code>vmlinux.lds.S</code>, <code>Makefile</code>。并按照以下步骤将这些文件正确放置。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">.</span><br><span class="hljs-bullet"></span>└── arch<br><span class="hljs-code">    └── riscv</span><br><span class="hljs-code">        └── kernel</span><br><span class="hljs-code">            ├── Makefile</span><br><span class="hljs-code">            └── vmlinux.lds.S</span><br></code></pre></td></tr></table></figure><p>这里我们通过 <code>vmlinux.lds.S</code> 模版生成 <code>vmlinux.lds</code>文件。链接脚本中的 <code>ramv</code> 代表 <code>VMA ( Virtual Memory Address )</code> 即虚拟地址，<code>ram</code> 则代表 <code>LMA ( Load Memory Address )</code>, 即我们 OS image 被 load 的地址，可以理解为物理地址。使用以上的 vmlinux.lds 进行编译之后，得到的 <code>System.map</code> 以及 <code>vmlinux</code> 采用的都是虚拟地址，方便之后 Debug。</p></li></ul><h3 id="4-2-开启虚拟内存映射。"><a href="#4-2-开启虚拟内存映射。" class="headerlink" title="4.2 开启虚拟内存映射。"></a>4.2 开启虚拟内存映射。</h3><p>在 RISC-V 中开启虚拟地址被分为了两步：<code>setup_vm</code> 以及 <code>setup_vm_final</code>，下面将介绍相关的具体实现。</p><h4 id="4-2-1-setup-vm-的实现"><a href="#4-2-1-setup-vm-的实现" class="headerlink" title="4.2.1 setup_vm 的实现"></a>4.2.1 <code>setup_vm</code> 的实现</h4><ul><li><p>将 0x80000000 开始的 1GB 区域进行两次映射，其中一次是等值映射 ( PA &#x3D;&#x3D; VA ) ，另一次是将其映射至高地址 ( PA + PV2VA_OFFSET &#x3D;&#x3D; VA )。如下图所示：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs text">Physical Address<br>-------------------------------------------<br>                     | OpenSBI | Kernel |<br>-------------------------------------------<br>                     ^<br>                0x80000000<br>                     ├───────────────────────────────────────────────────┐<br>                     |                                                   |<br>Virtual Address      ↓                                                   ↓<br>-----------------------------------------------------------------------------------------------<br>                     | OpenSBI | Kernel |                                | OpenSBI | Kernel |<br>-----------------------------------------------------------------------------------------------<br>                     ^                                                   ^<br>                0x80000000                                       0xffffffe000000000<br></code></pre></td></tr></table></figure></li><li><p>完成上述映射之后，通过 <code>relocate</code> 函数，完成对 <code>satp</code> 的设置，以及跳转到对应的虚拟地址。</p></li><li><p>至此我们已经完成了虚拟地址的开启，之后我们运行的代码也都将在虚拟地址上运行。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// arch/riscv/kernel/vm.c</span><br><br><span class="hljs-comment">/* early_pgtbl: 用于 setup_vm 进行 1GB 的 映射。 */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>  early_pgtbl[<span class="hljs-number">512</span>] __attribute__((__aligned__(<span class="hljs-number">0x1000</span>)));<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">setup_vm</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-comment">/* </span><br><span class="hljs-comment">    1. 由于是进行 1GB 的映射 这里不需要使用多级页表 </span><br><span class="hljs-comment">    2. 将 va 的 64bit 作为如下划分： | high bit | 9 bit | 30 bit |</span><br><span class="hljs-comment">        high bit 可以忽略</span><br><span class="hljs-comment">        中间9 bit 作为 early_pgtbl 的 index</span><br><span class="hljs-comment">        低 30 bit 作为 页内偏移 这里注意到 30 = 9 + 9 + 12， 即我们只使用根页表， 根页表的每个 entry 都对应 1GB 的区域。 </span><br><span class="hljs-comment">    3. Page Table Entry 的权限 V | R | W | X 位设置为 1</span><br><span class="hljs-comment">    */</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs asm"># head.S<br><br>_start:<br><br>    call setup_vm<br>    call relocate<br><br>    ...<br><br>    j start_kernel<br><br>relocate:<br>    # set ra = ra + PA2VA_OFFSET<br>    # set sp = sp + PA2VA_OFFSET (If you have set the sp before)<br>   <br>    ###################### <br>    #   YOUR CODE HERE   #<br>    ######################<br><br>    # set satp with early_pgtbl<br>    <br>    ###################### <br>    #   YOUR CODE HERE   #<br>    ######################<br>    <br>    # flush tlb<br>    sfence.vma zero, zero<br><br>    # flush icache<br>    fence.i<br><br>    ret<br><br>    .section .bss.stack<br>    .globl boot_stack<br>boot_stack:<br>    ...<br></code></pre></td></tr></table></figure><blockquote><p>Hint 1: <code>sfence.vma</code> 指令用于刷新 TLB</p><p>Hint 2: <code>fence.i</code> 指令用于刷新 icache</p><p>Hint 3: 在 set satp 前，我们只可以使用<strong>物理地址</strong>来打断点。设置 satp 之后，才可以使用虚拟地址打断点，同时之前设置的物理地址断点也会失效，需要删除</p></blockquote><h4 id="4-2-2-setup-vm-final-的实现"><a href="#4-2-2-setup-vm-final-的实现" class="headerlink" title="4.2.2 setup_vm_final 的实现"></a>4.2.2 <code>setup_vm_final</code> 的实现</h4><ul><li><p>由于 setup_vm_final 中需要申请页面的接口， 应该在其之前完成内存管理初始化， 可能需要修改 mm.c 中的代码，mm.c 中初始化的函数接收的起始结束地址需要调整为虚拟地址。</p></li><li><p>对 所有物理内存 (128M) 进行映射，并设置正确的权限。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs text">Physical Address<br>     PHY_START                           PHY_END<br>         ↓                                  ↓<br>--------------------------------------------------------<br>         | OpenSBI | Kernel |               |<br>--------------------------------------------------------<br>         ^                                  ^<br>    0x80000000                              └───────────────────────────────────────────────────┐<br>         └───────────────────────────────────────────────────┐                                  |<br>                                                             |                                  |<br>                                                          VM_START                              |<br>Virtual Address                                              ↓                                  ↓<br>----------------------------------------------------------------------------------------------------<br>                                                             | OpenSBI | Kernel |               |<br>-----------------------------------------------------------------------------------------------------<br>                                                             ^<br>                                                     0xffffffe000000000<br></code></pre></td></tr></table></figure></li><li><p>不再需要进行等值映射</p></li><li><p>不再需要将 OpenSBI 的映射至高地址，因为 OpenSBI 运行在 M 态， 直接使用的物理地址。</p></li><li><p>采用三级页表映射。</p></li><li><p>在 head.S 中 适当的位置调用 setup_vm_final 。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// arch/riscv/kernel/vm.c </span><br><br><span class="hljs-comment">/* swapper_pg_dir: kernel pagetable 根目录， 在 setup_vm_final 进行映射。 */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>  swapper_pg_dir[<span class="hljs-number">512</span>] __attribute__((__aligned__(<span class="hljs-number">0x1000</span>)));<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">setup_vm_final</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-built_in">memset</span>(swapper_pg_dir, <span class="hljs-number">0x0</span>, PGSIZE);<br><br>    <span class="hljs-comment">// No OpenSBI mapping required</span><br><br>    <span class="hljs-comment">// mapping kernel text X|-|R|V</span><br>    create_mapping(...);<br><br>    <span class="hljs-comment">// mapping kernel rodata -|-|R|V</span><br>    create_mapping(...);<br>    <br>    <span class="hljs-comment">// mapping other memory -|W|R|V</span><br>    create_mapping(...);<br>    <br>    <span class="hljs-comment">// set satp with swapper_pg_dir</span><br><br>    YOUR CODE HERE<br><br>    <span class="hljs-comment">// flush TLB</span><br>    <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;sfence.vma zero, zero&quot;</span>)</span>;<br>  <br>    <span class="hljs-comment">// flush icache</span><br>    <span class="hljs-keyword">asm</span> <span class="hljs-title function_">volatile</span><span class="hljs-params">(<span class="hljs-string">&quot;fence.i&quot;</span>)</span><br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><br><br><span class="hljs-comment">/* 创建多级页表映射关系 */</span><br>create_mapping(uint64 *pgtbl, uint64 va, uint64 pa, uint64 sz, <span class="hljs-type">int</span> perm) &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    pgtbl 为根页表的基地址</span><br><span class="hljs-comment">    va, pa 为需要映射的虚拟地址、物理地址</span><br><span class="hljs-comment">    sz 为映射的大小</span><br><span class="hljs-comment">    perm 为映射的读写权限</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    创建多级页表的时候可以使用 kalloc() 来获取一页作为页表目录</span><br><span class="hljs-comment">    可以使用 V bit 来判断页表项是否存在</span><br><span class="hljs-comment">    */</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-3-编译及测试"><a href="#4-3-编译及测试" class="headerlink" title="4.3 编译及测试"></a>4.3 编译及测试</h3><ul><li><p>由于加入了一些新的 .c 文件，可能需要修改一些Makefile文件，请同学自己尝试修改，使项目可以编译并运行。</p></li><li><p>输出示例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs bash">OpenSBI v0.9<br>  ____                    _____ ____ _____<br> / __ \                  / ____|  _ \_   _|<br>| |  | |_ __   ___ _ __ | (___ | |_) || |<br>| |  | | <span class="hljs-string">&#x27;_ \ / _ \ &#x27;</span>_ \ \___ \|  _ &lt; | |<br>| |__| | |_) |  __/ | | |____) | |_) || |_<br> \____/| .__/ \___|_| |_|_____/|____/_____|<br>       | |<br>       |_|<br><br>...<br><br>Boot HART MIDELEG         : 0x0000000000000222<br>Boot HART MEDELEG         : 0x000000000000b109<br><br>...mm_init <span class="hljs-keyword">done</span>!<br>...proc_init <span class="hljs-keyword">done</span>!<br>Hello RISC-V<br>idle process is running!<br><br>switch to [PID = 28 COUNTER = 1] <br>[PID = 28] is running! thread space begin at 0xffffffe007fa2000<br><br>switch to [PID = 12 COUNTER = 1] <br>[PID = 12] is running! thread space begin at 0xffffffe007fb2000<br><br>switch to [PID = 14 COUNTER = 2] <br>[PID = 14] is running! thread space begin at 0xffffffe007fb0000<br>[PID = 14] is running! thread space begin at 0xffffffe007fb0000<br><br>switch to [PID = 9 COUNTER = 2] <br>[PID = 9] is running! thread space begin at 0xffffffe007fb5000<br>[PID = 9] is running! thread space begin at 0xffffffe007fb5000<br><br>switch to [PID = 2 COUNTER = 2] <br>[PID = 2] is running! thread space begin at 0xffffffe007fbc000<br>[PID = 2] is running! thread space begin at 0xffffffe007fbc000<br><br>switch to [PID = 1 COUNTER = 2] <br>[PID = 1] is running! thread space begin at 0xffffffe007fbd000<br>[PID = 1] is running! thread space begin at 0xffffffe007fbd000<br><br>switch to [PID = 29 COUNTER = 3] <br>[PID = 29] is running! thread space begin at 0xffffffe007fa1000<br>[PID = 29] is running! thread space begin at 0xffffffe007fa1000<br>[PID = 29] is running! thread space begin at 0xffffffe007fa1000<br><br>switch to [PID = 11 COUNTER = 3] <br>[PID = 11] is running! thread space begin at 0xffffffe007fb3000<br>...<br><br></code></pre></td></tr></table></figure></li></ul><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><ol><li>验证 <code>.text</code>, <code>.rodata</code> 段的属性是否成功设置，给出截图。</li><li>为什么我们在 <code>setup_vm</code> 中需要做等值映射?</li><li>在 Linux 中，是不需要做等值映射的。请探索一下不在 <code>setup_vm</code> 中做等值映射的方法。</li></ol><h2 id="作业提交"><a href="#作业提交" class="headerlink" title="作业提交"></a>作业提交</h2><p>同学需要提交实验报告以及整个工程代码，在提交前请使用 <code>make clean</code> 清除所有构建产物。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="操作系统" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="os实验文档" scheme="http://example.com/tags/os%E5%AE%9E%E9%AA%8C%E6%96%87%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title>oslab3</title>
    <link href="http://example.com/2023/07/08/oslab3/"/>
    <id>http://example.com/2023/07/08/oslab3/</id>
    <published>2023-07-08T06:43:07.000Z</published>
    <updated>2023-07-29T05:52:30.886Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Lab-3-RV64-内核线程调度"><a href="#Lab-3-RV64-内核线程调度" class="headerlink" title="Lab 3: RV64 内核线程调度"></a>Lab 3: RV64 内核线程调度</h1><h2 id="1-实验目的"><a href="#1-实验目的" class="headerlink" title="1 实验目的"></a>1 实验目的</h2><ul><li>了解线程概念, 并学习线程相关结构体, 并实现线程的初始化功能。</li><li>了解如何使用时钟中断来实现线程的调度。</li><li>了解线程切换原理, 并实现线程的切换。</li><li>掌握简单的线程调度算法, 并完成两种简单调度算法的实现。</li></ul><h2 id="2-实验环境"><a href="#2-实验环境" class="headerlink" title="2 实验环境"></a>2 实验环境</h2><ul><li>Environment in previous labs</li></ul><h2 id="3-背景知识"><a href="#3-背景知识" class="headerlink" title="3 背景知识"></a>3 背景知识</h2><h3 id="3-0-前言"><a href="#3-0-前言" class="headerlink" title="3.0 前言"></a>3.0 前言</h3><p>在 lab2 中, 我们利用 trap 赋予了 OS 与软件, 硬件的交互能力。但是目前我们的 OS 还不具备多进程调度以及并发执行的能力。在本次实验中, 我们将利用时钟中断, 来实现多进程的调度以使得多个进程&#x2F;线程并发执行。</p><h3 id="3-1-进程与线程"><a href="#3-1-进程与线程" class="headerlink" title="3.1 进程与线程"></a>3.1 进程与线程</h3><p><code>源代码</code>经编译器一系列处理（编译、链接、优化等）后得到的可执行文件, 我们称之为<code>程序 (Program)</code>。而通俗地说, <code>进程</code>就是<code>正在运行并使用计算机资源</code>的程序。<code>进程</code>与<code>程序</code>的不同之处在于, <code>进程</code>是一个动态的概念, 其不仅需要将其运行的程序的代码&#x2F;数据等加载到内存空间中, 还需要拥有自己的<code>运行栈</code>。同时一个<code>进程</code>可以对应一个或多个<code>线程</code>, <code>线程</code>之间往往具有相同的代码, 共享一块内存, 但是却有不同的CPU执行状态。</p><p>在本次实验中, 为了简单起见,  我们采用 <code>single-threaded process</code> 模型,  即<code>一个进程</code>对应<code>一个线程</code>, 进程与线程不做明显区分。</p><h3 id="3-1-线程相关属性"><a href="#3-1-线程相关属性" class="headerlink" title="3.1 线程相关属性"></a>3.1 线程相关属性</h3><p>在不同的操作系统中, 为每个线程所保存的信息都不同。在这里, 我们提供一种基础的实现, 每个线程会包括：</p><ul><li><code>线程ID</code>：用于唯一确认一个线程。</li><li><code>运行栈</code>：每个线程都必须有一个独立的运行栈, 保存运行时的数据。</li><li><code>执行上下文</code>：当线程不在执行状态时, 我们需要保存其上下文（其实就是<code>状态寄存器</code>的值）, 这样之后才能够将其恢复, 继续运行。</li><li><code>运行时间片</code>：为每个线程分配的运行时间。</li><li><code>优先级</code>：在优先级相关调度时, 配合调度算法, 来选出下一个执行的线程。</li></ul><h3 id="3-2-线程切换流程图"><a href="#3-2-线程切换流程图" class="headerlink" title="3.2 线程切换流程图"></a>3.2 线程切换流程图</h3><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs coq">          Process <span class="hljs-number">1</span>         Operating System            Process <span class="hljs-number">2</span><br>              +<br>              |                                            <span class="hljs-type">X</span><br>P1 executing  |                                            <span class="hljs-type">X</span><br>              |                                            <span class="hljs-type">X</span><br>              v Timer Interrupt Trap                       X<br>              +----------------------&gt;                     X<br>                                     +                     X<br>              X                  do_timer()                X<br>              X                      +                     X<br>              X                  schedule()                X<br>              X                      +                     X<br>              X              save state to PCB1            X<br>              X                      +                     X<br>              X           restore state from PCB2          X<br>              X                      +                     X<br>              X                      |                     <span class="hljs-type">X</span><br>              X                      v Timer Interrupt Ret<br>              X                      +---------------------&gt;<br>              X                                            |<br>              <span class="hljs-type">X</span>                                            |  <span class="hljs-type">P2</span> executing<br>              X                                            |<br>              <span class="hljs-type">X</span>                       Timer Interrupt Trap v<br>              X                      &lt;---------------------+<br>              X                      +<br>              X                  do_timer()<br>              X                      +<br>              X                  schedule()<br>              X                      +<br>              X              save state to PCB2<br>              X                      +<br>              X           restore state from PCB1<br>              X                      +<br>              X                      |<br>                <span class="hljs-type">Timer</span> Interrupt Ret  v<br>              &lt;----------------------+<br>              |<br><span class="hljs-type">P1</span> executing  |<br>              <span class="hljs-type">|</span><br><span class="hljs-type">              v</span><br></code></pre></td></tr></table></figure><ul><li>在每次处理时钟中断时, 操作系统首先会将当前线程的运行剩余时间减少一个单位。之后根据调度算法来确定是继续运行还是调度其他线程来执行。</li><li>在进程调度时, 操作系统会遍历所有可运行的线程, 按照一定的调度算法选出下一个执行的线程。最终将选择得到的线程与当前线程切换。</li><li>在切换的过程中, 首先我们需要保存当前线程的执行上下文, 再将将要执行线程的上下文载入到相关寄存器中, 至此我们就完成了线程的调度与切换。</li></ul><h2 id="4-实验步骤"><a href="#4-实验步骤" class="headerlink" title="4 实验步骤"></a>4 实验步骤</h2><h3 id="4-1-准备工程"><a href="#4-1-准备工程" class="headerlink" title="4.1 准备工程"></a>4.1 准备工程</h3><ul><li><p>此次实验基于 lab2 同学所实现的代码进行。</p></li><li><p>从 <code>repo</code> 同步以下代码: <code>rand.h/rand.c</code>, <code>string.h/string.c</code>, <code>mm.h/mm.c</code>。并按照以下步骤将这些文件正确放置。其中 <code>mm.h/mm.c</code> 提供了简单的物理内存管理接口, <code>rand.h/rand.c</code>提供了 <code>rand()</code> 接口用以提供伪随机数序列, <code>string.h/string.c</code>提供了 <code>memset</code> 接口用以初始化一段内存空间。</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs verilog">.<br>├── arch<br>│   └── riscv<br>│       ├── <span class="hljs-keyword">include</span><br>│       │   └── mm<span class="hljs-variable">.h</span><br>│       └── kernel<br>│           └── mm<span class="hljs-variable">.c</span><br>├── <span class="hljs-keyword">include</span><br>│   ├── <span class="hljs-keyword">rand</span><span class="hljs-variable">.h</span><br>│   └── <span class="hljs-keyword">string</span><span class="hljs-variable">.h</span><br>└── lib<br>    ├── <span class="hljs-keyword">rand</span><span class="hljs-variable">.c</span><br>    └── <span class="hljs-keyword">string</span><span class="hljs-variable">.c</span><br></code></pre></td></tr></table></figure></li><li><p>在 lab3 中我们需要一些物理内存管理的接口, 在此我们提供了 <code>kalloc</code> 接口 ( 见<code>mm.c</code> ) 给同学。同学可以用 <code>kalloc</code> 来申请 4KB 的物理页。由于引入了简单的物理内存管理, 需要在 <code>_start</code> 的适当位置调用 <code>mm_init</code>, 来初始化内存管理系统, 并且在初始化时需要用一些自定义的宏, 需要修改 <code>defs.h</code>, 在 <code>defs.h</code> 添加如下内容：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PHY_START 0x0000000080000000</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PHY_SIZE  128 * 1024 * 1024 <span class="hljs-comment">// 128MB,  QEMU 默认内存大小</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PHY_END   (PHY_START + PHY_SIZE)</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PGSIZE 0x1000 <span class="hljs-comment">// 4KB</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PGROUNDUP(addr) ((addr + PGSIZE - 1) &amp; (~(PGSIZE - 1)))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PGROUNDDOWN(addr) (addr &amp; (~(PGSIZE - 1)))</span><br></code></pre></td></tr></table></figure></li><li><p>请在添加&#x2F;修改上述文件代码之后, 确保工程可以正常运行, 之后再开始实现 <code>lab3</code> (有可能需要同学自己调整一些头文件的引入)。</p></li><li><p>在 lab3 中需要同学需要添加并修改 <code>arch/riscv/include/proc.h</code> <code>arch/riscv/kernel/proc.c</code> 两个文件。</p></li><li><p>本次实验需要实现两种不同的调度算法,  如何控制代码逻辑见 <code>4.4</code></p></li></ul><h3 id="4-2-proc-h-数据结构定义"><a href="#4-2-proc-h-数据结构定义" class="headerlink" title="4.2 proc.h 数据结构定义"></a>4.2 <code>proc.h</code> 数据结构定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// arch/riscv/include/proc.h</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;types.h&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NR_TASKS  (1 + 31) <span class="hljs-comment">// 用于控制 最大线程数量 （idle 线程 + 31 内核线程）</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> TASK_RUNNING    0 <span class="hljs-comment">// 为了简化实验, 所有的线程都只有一种状态</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRIORITY_MIN 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PRIORITY_MAX 10</span><br><br><span class="hljs-comment">/* 用于记录 `线程` 的 `内核栈与用户栈指针` */</span><br><span class="hljs-comment">/* (lab3中无需考虑, 在这里引入是为了之后实验的使用) */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">thread_info</span> &#123;<br>    uint64 kernel_sp;<br>    uint64 user_sp;<br>&#125;;<br><br><span class="hljs-comment">/* 线程状态段数据结构 */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">thread_struct</span> &#123;<br>    uint64 ra;<br>    uint64 sp;<br>    uint64 s[<span class="hljs-number">12</span>];<br>&#125;;<br><br><span class="hljs-comment">/* 线程数据结构 */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">task_struct</span> &#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">thread_info</span>* thread_info;<br>    uint64 state;    <span class="hljs-comment">// 线程状态</span><br>    uint64 counter;  <span class="hljs-comment">// 运行剩余时间</span><br>    uint64 priority; <span class="hljs-comment">// 运行优先级 1最低 10最高</span><br>    uint64 pid;      <span class="hljs-comment">// 线程id</span><br><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">thread_struct</span> thread;<br>&#125;;<br><br><span class="hljs-comment">/* 线程初始化 创建 NR_TASKS 个线程 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">task_init</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">/* 在时钟中断处理中被调用 用于判断是否需要进行调度 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">do_timer</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">/* 调度程序 选择出下一个运行的线程 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">schedule</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">/* 线程切换入口函数*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">switch_to</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> task_struct* next)</span></span>;<br><br><span class="hljs-comment">/* dummy funciton: 一个循环程序, 循环输出自己的 pid 以及一个自增的局部变量 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dummy</span><span class="hljs-params">()</span></span>;<br><br></code></pre></td></tr></table></figure><h3 id="4-3-线程调度功能实现"><a href="#4-3-线程调度功能实现" class="headerlink" title="4.3 线程调度功能实现"></a>4.3 线程调度功能实现</h3><h4 id="4-3-1-线程初始化"><a href="#4-3-1-线程初始化" class="headerlink" title="4.3.1 线程初始化"></a>4.3.1 线程初始化</h4><ul><li><p>在初始化线程的时候, 我们参考<a href="https://elixir.bootlin.com/linux/0.11/source/kernel/fork.c#L93">Linux v0.11中的实现</a>为每个线程分配一个 4KB 的物理页, 我们将 <code>task_struct</code> 存放在该页的低地址部分,  将线程的栈指针 <code>sp</code> 指向该页的高地址。具体内存布局如下图所示：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs css">                ┌─────────────┐◄─── High <span class="hljs-selector-tag">Address</span><br>                │             │<br>                │    stack    │<br>                │             │<br>                │             │<br>          sp ──►├──────┬──────┤<br>                │      │      │<br>                │      ▼      │<br>                │             │<br>                │             │<br>                │             │<br>                │             │<br><span class="hljs-number">4</span>KB Page        │             │<br>                │             │<br>                │             │<br>                │             │<br>                ├─────────────┤<br>                │             │<br>                │             │<br>                │ task_struct │<br>                │             │<br>                │             │<br>                └─────────────┘◄─── Low <span class="hljs-selector-tag">Address</span><br></code></pre></td></tr></table></figure></li><li><p>当我们的 OS run 起来的时候, 其本身就是一个线程 <code>idle 线程</code>, 但是我们并没有为它设计好 <code>task_struct</code>。所以第一步我们要为 <code>idle</code> 设置 <code>task_struct</code>。并将 <code>current</code>, <code>task[0]</code> 都指向 <code>idle</code>。</p></li><li><p>为了方便起见, 我们将 <code>task[1]</code> ~ <code>task[NR_TASKS - 1]</code>, 全部初始化,  这里和 <code>idle</code> 设置的区别在于要为这些线程设置 <code>thread_struct</code> 中的 <code>ra</code> 和 <code>sp</code>.</p></li><li><p>在 <code>_start</code> 适当的位置调用 <code>task_init</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//arch/riscv/kernel/proc.c</span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> __dummy();<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">task_struct</span>* idle;           <span class="hljs-comment">// idle process</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">task_struct</span>* current;        <span class="hljs-comment">// 指向当前运行线程的 `task_struct`</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">task_struct</span>* task[NR_TASKS]; <span class="hljs-comment">// 线程数组, 所有的线程都保存在此</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">task_init</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 1. 调用 kalloc() 为 idle 分配一个物理页</span><br>    <span class="hljs-comment">// 2. 设置 state 为 TASK_RUNNING;</span><br>    <span class="hljs-comment">// 3. 由于 idle 不参与调度 可以将其 counter / priority 设置为 0</span><br>    <span class="hljs-comment">// 4. 设置 idle 的 pid 为 0</span><br>    <span class="hljs-comment">// 5. 将 current 和 task[0] 指向 idle</span><br><br>    <span class="hljs-comment">/* YOUR CODE HERE */</span><br><br>    <span class="hljs-comment">// 1. 参考 idle 的设置, 为 task[1] ~ task[NR_TASKS - 1] 进行初始化</span><br>    <span class="hljs-comment">// 2. 其中每个线程的 state 为 TASK_RUNNING, counter 为 0, priority 使用 rand() 来设置, pid 为该线程在线程数组中的下标。</span><br>    <span class="hljs-comment">// 3. 为 task[1] ~ task[NR_TASKS - 1] 设置 `thread_struct` 中的 `ra` 和 `sp`,</span><br>    <span class="hljs-comment">// 4. 其中 `ra` 设置为 __dummy （见 4.3.2）的地址,  `sp` 设置为 该线程申请的物理页的高地址</span><br><br>    <span class="hljs-comment">/* YOUR CODE HERE */</span><br><br>    <span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;...proc_init done!\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><blockquote><p>Debug 提示：</p><ol><li>修改 <code>proc.h</code> 中的 <code>NR_TASKS</code> 为一个比较小的值, 比如 5,  这样 除去 <code>task[0]</code> ( idle ), 只需要初始化 4 个线程, 方便调试。</li><li>注意以上的修改只是为了在做实验的过程中方便调试, 最后一定记住要修改回去！！！</li></ol></blockquote><h4 id="4-3-2-dummy-与-dummy-介绍"><a href="#4-3-2-dummy-与-dummy-介绍" class="headerlink" title="4.3.2 __dummy 与 dummy 介绍"></a>4.3.2 <code>__dummy</code> 与 <code>dummy</code> 介绍</h4><ul><li><p><code>task[1]</code> ~ <code>task[NR_TASKS - 1]</code>都运行同一段代码 <code>dummy()</code> 我们在 <code>proc.c</code> 添加 <code>dummy()</code>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// arch/riscv/kernel/proc.c</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dummy</span><span class="hljs-params">()</span> </span>&#123;<br>    uint64 MOD = <span class="hljs-number">1000000007</span>;<br>    uint64 auto_inc_local_var = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> last_counter = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (last_counter == <span class="hljs-number">-1</span> || current-&gt;counter != last_counter) &#123;<br>            last_counter = current-&gt;counter;<br>            auto_inc_local_var = (auto_inc_local_var + <span class="hljs-number">1</span>) % MOD;<br>            <span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;[PID = %d] is running. auto_inc_local_var = %d\n&quot;</span>, current-&gt;pid, auto_inc_local_var);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><blockquote><p>Debug 提示： 可以用 printk 打印更多的信息</p></blockquote><ul><li><p>当线程在运行时, 由于时钟中断的触发, 会将当前运行线程的上下文环境保存在栈上。当线程再次被调度时, 会将上下文从栈上恢复, 但是当我们创建一个新的线程, 此时线程的栈为空, 当这个线程被调度时, 是没有上下文需要被恢复的, 所以我们需要为线程<code>第一次调度</code>提供一个特殊的返回函数 <code>__dummy</code></p></li><li><p>在 <code>entry.S</code> 添加 <code>__dummy</code></p><ul><li>在<code>__dummy</code> 中将 sepc 设置为 <code>dummy()</code> 的地址, 并使用 <code>sret</code> 从中断中返回。</li><li><code>__dummy</code> 与 <code>_traps</code>的 <code>restore</code> 部分相比, 其实就是省略了从栈上恢复上下文的过程 ( 但是手动设置了 <code>sepc</code> )。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs asm"># arch/riscv/kernel/entry.S<br><br>    .global __dummy<br>__dummy:<br>    # YOUR CODE HERE<br></code></pre></td></tr></table></figure></li></ul><h4 id="4-3-3-实现线程切换"><a href="#4-3-3-实现线程切换" class="headerlink" title="4.3.3 实现线程切换"></a>4.3.3 实现线程切换</h4><ul><li><p>判断下一个执行的线程 <code>next</code> 与当前的线程 <code>current</code> 是否为同一个线程, 如果是同一个线程, 则无需做任何处理, 否则调用 <code>__switch_to</code> 进行线程切换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// arch/riscv/kernel/proc.c</span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-type">void</span> __switch_to(<span class="hljs-keyword">struct</span> task_struct* prev, <span class="hljs-keyword">struct</span> task_struct* next);<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">switch_to</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> task_struct* next)</span> </span>&#123;<br>    <span class="hljs-comment">/* YOUR CODE HERE */</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在 <code>entry.S</code> 中实现线程上下文切换 <code>__switch_to</code>:</p><ul><li><code>__switch_to</code>接受两个 <code>task_struct</code> 指针作为参数</li><li>保存当前线程的<code>ra</code>, <code>sp</code>, <code>s0~s11</code>到当前线程的 <code>thread_struct</code> 中</li><li>将下一个线程的 <code>thread_struct</code> 中的相关数据载入到<code>ra</code>, <code>sp</code>, <code>s0~s11</code>中。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs asm"># arch/riscv/kernel/entry.S<br><br>    .globl __switch_to<br>__switch_to:<br>    # save state to prev process<br>    # YOUR CODE HERE<br><br>    # restore state from next process<br>    # YOUR CODE HERE<br><br>    ret<br></code></pre></td></tr></table></figure></li></ul><blockquote><p>Debug 提示： 可以尝试是否可以从 idle 正确切换到 process 1</p></blockquote><h4 id="4-3-4-实现调度入口函数"><a href="#4-3-4-实现调度入口函数" class="headerlink" title="4.3.4 实现调度入口函数"></a>4.3.4 实现调度入口函数</h4><ul><li><p>实现 <code>do_timer()</code>, 并在 <code>时钟中断处理函数</code> 中调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// arch/riscv/kernel/proc.c</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">do_timer</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>    <span class="hljs-comment">// 1. 如果当前线程是 idle 线程 直接进行调度</span><br>    <span class="hljs-comment">// 2. 如果当前线程不是 idle 对当前线程的运行剩余时间减1 若剩余时间仍然大于0 则直接返回 否则进行调度</span><br><br>    <span class="hljs-comment">/* YOUR CODE HERE */</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="4-3-5-实现线程调度"><a href="#4-3-5-实现线程调度" class="headerlink" title="4.3.5 实现线程调度"></a>4.3.5 实现线程调度</h4><p>本次实验我们需要实现两种调度算法：1.短作业优先调度算法, 2.优先级调度算法。</p><h5 id="4-3-5-1-短作业优先调度算法"><a href="#4-3-5-1-短作业优先调度算法" class="headerlink" title="4.3.5.1 短作业优先调度算法"></a>4.3.5.1 短作业优先调度算法</h5><ul><li><p>当需要进行调度时按照一下规则进行调度：</p><ul><li>遍历线程指针数组<code>task</code>(不包括 <code>idle</code> , 即 <code>task[0]</code> ), 在所有运行状态 (<code>TASK_RUNNING</code>) 下的线程运行剩余时间<code>最少</code>的线程作为下一个执行的线程。</li><li>如果<code>所有</code>运行状态下的线程运行剩余时间都为0, 则对 <code>task[1]</code> ~ <code>task[NR_TASKS-1]</code> 的运行剩余时间重新赋值 (使用 <code>rand()</code>) , 之后再重新进行调度。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// arch/riscv/kernel/proc.c</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">schedule</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>    <span class="hljs-comment">/* YOUR CODE HERE */</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Debug 提示：可以先将 <code>NR_TASKS</code> 改为较小的值, 调用 <code>printk</code> 将所有线程的信息打印出来。</p></blockquote></li></ul><h5 id="4-3-5-2-优先级调度算法"><a href="#4-3-5-2-优先级调度算法" class="headerlink" title="4.3.5.2 优先级调度算法"></a>4.3.5.2 优先级调度算法</h5><ul><li><p>参考 <a href="https://elixir.bootlin.com/linux/0.11/source/kernel/sched.c#L122">Linux v0.11 调度算法实现</a> 实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// arch/riscv/kernel/proc.c</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">schedule</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>    <span class="hljs-comment">/* YOUR CODE HERE */</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="4-4-编译及测试"><a href="#4-4-编译及测试" class="headerlink" title="4.4 编译及测试"></a>4.4 编译及测试</h3><ul><li><p>由于加入了一些新的 .c 文件, 可能需要修改一些Makefile文件, 请同学自己尝试修改, 使项目可以编译并运行。</p></li><li><p>由于本次实验需要完成两个调度算法, 因此需要两种调度算法可以使用<a href="https://www.rapidtables.com/code/linux/gcc/gcc-d.html"><code>gcc –D</code></a>选项进行控制。</p><ul><li>DSJF （短作业优先调度）。</li><li>DPRIORITY （优先级调度）。</li><li>在<code>proc.c</code>中使用 <code>#ifdef</code> , <code>#endif</code> 来控制代码。 修改顶层Makefile为 <code>CFLAG = $&#123;CF&#125; $&#123;INCLUDE&#125; -DSJF</code> 或 <code>CFLAG = $&#123;CF&#125; $&#123;INCLUDE&#125; -DPRIORITY</code> (作业提交的时候 <code>Makefile</code> 选择任意一个都可以)</li></ul></li><li><p>短作业优先调度输出示例 (为了便于展示, 这里一共只初始化了 4 个线程) 同学们最后提交时需要 保证 NR_TASKS 为 32 不变</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">OpenSBI v0.9<br>  ____                    _____ ____ _____<br> / __ \                  / ____|  _ \_   _|<br>| |  | |_ __   ___ _ __ | (___ | |_) || |<br>| |  | | &#x27;_ \ / _ \ &#x27;_ \ \___ \|  _ &lt; | |<br>| |__| | |_) |  __/ | | |____) | |_) || |_<br> \____/| .__/ \___|_| |_|_____/|____/_____|<br>       | |<br>       |_|<br><br>...<br><br>Boot HART MIDELEG         : 0x0000000000000222<br>Boot HART MEDELEG         : 0x000000000000b109<br><br>...mm_init done!<br>...proc_init done!<br>Hello RISC-V<br>idle process is running!<br><br>SET [PID = 1 COUNTER = 10]<br>SET [PID = 2 COUNTER = 10]<br>SET [PID = 3 COUNTER = 5]<br>SET [PID = 4 COUNTER = 2]<br><br>switch to [PID = 4 COUNTER = 2]<br>[PID = 4] is running. auto_inc_local_var = 1<br>[PID = 4] is running. auto_inc_local_var = 2<br><br>switch to [PID = 3 COUNTER = 5]<br>[PID = 3] is running. auto_inc_local_var = 1<br>.....<br>[PID = 3] is running. auto_inc_local_var = 5<br><br>switch to [PID = 2 COUNTER = 10]<br>[PID = 2] is running. auto_inc_local_var = 1<br>...<br>[PID = 2] is running. auto_inc_local_var = 10<br><br>switch to [PID = 1 COUNTER = 10]<br>[PID = 1] is running. auto_inc_local_var = 1<br>...<br>[PID = 1] is running. auto_inc_local_var = 10<br><br>SET [PID = 1 COUNTER = 9]<br>SET [PID = 2 COUNTER = 4]<br>SET [PID = 3 COUNTER = 4]<br>SET [PID = 4 COUNTER = 10]<br><br>switch to [PID = 3 COUNTER = 4]<br>[PID = 3] is running. auto_inc_local_var = 6<br>...<br>[PID = 3] is running. auto_inc_local_var = 9<br><br></code></pre></td></tr></table></figure></li><li><p>优先级调度输出示例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">OpenSBI v0.9<br>  ____                    _____ ____ _____<br> / __ \                  / ____|  _ \_   _|<br>| |  | |_ __   ___ _ __ | (___ | |_) || |<br>| |  | | &#x27;_ \ / _ \ &#x27;_ \ \___ \|  _ &lt; | |<br>| |__| | |_) |  __/ | | |____) | |_) || |_<br> \____/| .__/ \___|_| |_|_____/|____/_____|<br>       | |<br>       |_|<br><br>...<br><br>Boot HART MIDELEG         : 0x0000000000000222<br>Boot HART MEDELEG         : 0x000000000000b109<br><br>...mm_init done!<br>...proc_init done!<br>Hello RISC-V<br>idle process is running!<br><br>SET [PID = 1 PRIORITY = 1 COUNTER = 1]<br>SET [PID = 2 PRIORITY = 4 COUNTER = 4]<br>SET [PID = 3 PRIORITY = 10 COUNTER = 10]<br>SET [PID = 4 PRIORITY = 4 COUNTER = 4]<br><br>switch to [PID = 3 PRIORITY = 10 COUNTER = 10]<br>[PID = 3] is running. auto_inc_local_var = 1<br>...<br>[PID = 3] is running. auto_inc_local_var = 10<br><br>switch to [PID = 4 PRIORITY = 4 COUNTER = 4]<br>[PID = 4] is running. auto_inc_local_var = 1<br>...<br>[PID = 4] is running. auto_inc_local_var = 4<br><br>switch to [PID = 2 PRIORITY = 4 COUNTER = 4]<br>[PID = 2] is running. auto_inc_local_var = 1<br>...<br>[PID = 2] is running. auto_inc_local_var = 4<br><br>switch to [PID = 1 PRIORITY = 1 COUNTER = 1]<br>[PID = 1] is running. auto_inc_local_var = 1<br><br>SET [PID = 1 PRIORITY = 1 COUNTER = 1]<br>SET [PID = 2 PRIORITY = 4 COUNTER = 4]<br>SET [PID = 3 PRIORITY = 10 COUNTER = 10]<br>SET [PID = 4 PRIORITY = 4 COUNTER = 4]<br><br>switch to [PID = 3 PRIORITY = 10 COUNTER = 10]<br>[PID = 3] is running. auto_inc_local_var = 11<br>...<br></code></pre></td></tr></table></figure></li></ul><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><ol><li><p>在 RV64 中一共用 32 个通用寄存器, 为什么 <code>context_switch</code> 中只保存了14个?</p></li><li><p>当线程第一次调用时, 其 <code>ra</code> 所代表的返回点是 <code>__dummy</code>。那么在之后的线程调用中 <code>context_switch</code> 中, <code>ra</code> 保存&#x2F;恢复的函数返回点是什么呢? 请同学用 gdb 尝试追踪一次完整的线程切换流程, 并关注每一次 <code>ra</code> 的变换 (需要截图)。</p></li><li><p>运行课堂 demo 的 <code>hello-lkm</code> 代码, 回答下列问题:</p><p>a. 对运行结果进行截图, 展示同一进程内的线程哪些数据 share, 哪些不 share</p><p>b. 安装 lkm 和 remove lkm 的命令分别是什么? 对内核进行了哪些改动?</p><p>c. 使用哪个内核函数可以输出到内核 log?</p><blockquote><p>特别地，如果你正在使用 <code>WSL2</code> 上的 <code>Ubuntu 22.04</code>，由于官方和浙大源中都没有给出对应版本的 <code>linux-headers</code>，所以需要我们从 Linux 源码开始编译 kernel module。你可以从微软的官方 <a href="https://github.com/microsoft/WSL2-Linux-Kernel">WSL2 Kernel Repository</a> 中获取到你正在使用的 WSL2 内核版本对应的源码。</p></blockquote><blockquote><p>例如我通过 <code>uname -r</code> 得到的结果是 <code>5.10.16.3-microsoft-standard-WSL2</code>，就需要从这个 Repo 的 <a href="https://github.com/microsoft/WSL2-Linux-Kernel#:~:text=8%20branches-,3%2C144%20tags,-Go%20to%20file">tags</a> 中找到 <a href="https://github.com/microsoft/WSL2-Linux-Kernel/tags#:~:text=linux%2Dmsft%2Dwsl%2D5.10.16.3">linux-msft-wsl-5.10.16.3</a> 的源码并下载解压。</p></blockquote><blockquote><p>在编译 <code>lkm</code> 之前，需要首先编译 Linux 内核，我们可以使用命令 <code>zcat /proc/config.gz &gt; .config</code> 来将当前运行的内核的配置直接复制到内核仓库中，然后直接进行 <code>make</code>。如果在编译的过程中遇到了部分选项没有配置的提示，可以一直敲回车来选择默认选项。</p></blockquote><blockquote><p>在编译完成以后，你需要阅读我们给出的 <code>lkm</code> 的 <code>Makefile</code> 来理解其具体行为，并将编译进行的目录指定为我们刚刚的内核目录（即是刚刚我们解压完成的名为 <code>WSL2-Linux-Kernel-linux-msft-wsl-5.10.16.3</code>，并进行了内核编译的目录），注意不用带上后面的 <code>build</code> 子目录路径，即可完成编译。</p></blockquote></li></ol><h2 id="作业提交"><a href="#作业提交" class="headerlink" title="作业提交"></a>作业提交</h2><p>同学需要提交实验报告以及整个工程代码。在提交前请使用 <code>make clean</code> 清除所有构建产物。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="操作系统" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="os实验文档" scheme="http://example.com/tags/os%E5%AE%9E%E9%AA%8C%E6%96%87%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title>oslab2</title>
    <link href="http://example.com/2023/07/08/oslab2/"/>
    <id>http://example.com/2023/07/08/oslab2/</id>
    <published>2023-07-08T06:43:03.000Z</published>
    <updated>2023-07-29T05:52:30.885Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Lab-2-RV64-时钟中断处理"><a href="#Lab-2-RV64-时钟中断处理" class="headerlink" title="Lab 2: RV64 时钟中断处理"></a>Lab 2: RV64 时钟中断处理</h1><h2 id="1-实验目的"><a href="#1-实验目的" class="headerlink" title="1 实验目的"></a>1 实验目的</h2><ul><li>学习 RISC-V 的 trap 处理相关寄存器与指令，完成对 trap 处理的初始化。</li><li>理解 CPU 上下文切换机制，并正确实现上下文切换功能。</li><li>编写 trap 处理函数，完成对特定 trap 的处理。</li><li>调用 OpenSBI 提供的接口，完成对时钟中断事件的设置。</li></ul><h2 id="2-实验环境"><a href="#2-实验环境" class="headerlink" title="2 实验环境"></a>2 实验环境</h2><ul><li>Environment in previous labs</li></ul><h2 id="3-背景知识"><a href="#3-背景知识" class="headerlink" title="3 背景知识"></a>3 背景知识</h2><h3 id="3-0-前言"><a href="#3-0-前言" class="headerlink" title="3.0 前言"></a>3.0 前言</h3><p>在 <a href="./lab1.md">lab1</a> 中我们成功的将一个最简单的 OS 启动起来， 但还没有办法与之交互。我们在课程中讲过操作系统启动之后由<strong>事件</strong>（<code>event</code>）驱动，在本次实验中我们将引入一种重要的事件 <strong>trap</strong>，trap 给了 OS 与硬件、软件交互的能力。在 <code>lab1</code> 中我们介绍了在 RISC-V 中有三种特权级 ( M 态、 S 态、 U 态 )， 在 Boot 阶段， OpenSBI 已经帮我们将 M 态的 trap 处理进行了初始化，这一部分不需要我们再去实现，因此本次试验我们重点关注 S 态的 trap 处理。</p><h3 id="3-1-RISC-V-中的-Interrupt-和-Exception"><a href="#3-1-RISC-V-中的-Interrupt-和-Exception" class="headerlink" title="3.1 RISC-V 中的 Interrupt 和 Exception"></a>3.1 RISC-V 中的 Interrupt 和 Exception</h3><h4 id="3-1-1-什么是-Interrupt-和-Exception"><a href="#3-1-1-什么是-Interrupt-和-Exception" class="headerlink" title="3.1.1 什么是 Interrupt 和 Exception"></a>3.1.1 什么是 Interrupt 和 Exception</h4><blockquote><p>We use the term <strong>exception</strong> to refer to an unusual condition occurring at run time <strong>associated with an instruction</strong> in the current RISC-V hart. We use the term <strong>interrupt</strong> to refer to an <strong>external asynchronous event</strong> that may cause a RISC-V hart to experience an unexpected transfer of control. We use the term <strong>trap</strong> to refer to <strong>the transfer of control to a trap handler</strong> caused by either an exception or an interrupt.</p></blockquote><p>上述是 <a href="https://github.com/riscv/riscv-isa-manual/releases/download/Ratified-IMAFDQC/riscv-spec-20191213.pdf">RISC-V Unprivileged Spec</a> 1.6 节中对于 <code>Trap</code>、 <code>Interrupt</code> 与 <code>Exception</code> 的描述。总结起来 <code>Interrupt</code> 与 <code>Exception</code> 的主要区别如下表：</p><table><thead><tr><th align="left">Interrupt</th><th align="left">Exception</th></tr></thead><tbody><tr><td align="left">Hardware generate</td><td align="left">Software generate</td></tr><tr><td align="left">These are <strong>asynchronous external requests</strong> for service (like keyboard or printer needs service).</td><td align="left">These are <strong>synchronous internal requests</strong> for service based upon abnormal events (think of illegal instructions, illegal address, overflow etc).</td></tr><tr><td align="left">These are <strong>normal events</strong> and shouldn’t interfere with the normal running of a computer.</td><td align="left">These are <strong>abnormal events</strong> and often result in the termination of a program</td></tr></tbody></table><p>上文中的 <code>Trap</code> 描述的是一种控制转移的过程, 这个过程是由 <code>Interrupt</code> 或者 <code>Exception</code> 引起的。这里为了方便起见，我们在这里约定 <code>Trap</code> 为 <code>Interrput</code> 与 <code>Exception</code> 的总称。</p><h4 id="3-1-2-相关寄存器"><a href="#3-1-2-相关寄存器" class="headerlink" title="3.1.2 相关寄存器"></a>3.1.2 相关寄存器</h4><p>除了32个通用寄存器之外，RISC-V 架构还有大量的 <strong>控制状态寄存器</strong> <code>Control and Status Registers(CSRs)</code>，下面将介绍几个和 trap 机制相关的重要寄存器。</p><p>Supervisor Mode 下 trap 相关寄寄存器:</p><ul><li><code>sstatus</code> ( Supervisor Status Register )中存在一个 SIE ( Supervisor Interrupt Enable ) 比特位，当该比特位设置为 1 时，会<strong>响应</strong>所有的 S 态 trap， 否则将会禁用所有 S 态 trap。</li><li><code>sie</code> ( Supervisor Interrupt Eable Register )。在 RISC-V 中，<code>Interrupt</code> 被划分为三类 <code>Software Interrupt</code>， <code>Timer Interrupt</code>， <code>External Interrupt</code>。在开启了 <code>sstatus[SIE]</code>之后，系统会根据 <code>sie</code> 中的相关比特位来决定是否对该 <code>Interrupt</code> 进行<strong>处理</strong>。</li><li><code>stvec</code> ( Supervisor Trap Vector Base Address Register ) 即所谓的“中断向量表基址”。 <code>stvec</code> 有两种模式：<code>Direct 模式</code>，适用于系统中只有一个中断处理程序, 其指向中断处理入口函数 （ 本次实验中我们所用的模式 ）。<code>Vectored 模式</code>，指向中断向量表， 适用于系统中有多个中断处理程序 （ 该模式可以参考<a href="https://elixir.bootlin.com/linux/latest/source/arch/riscv/kernel/entry.S#L564"> RISC-V 内核源码</a> ）。</li><li><code>scause</code> ( Supervisor Cause Register ), 会记录 trap 发生的原因，还会记录该 trap 是 <code>Interrupt</code> 还是 <code>Exception</code>。</li><li><code>sepc</code> ( Supervisor Exception Program Counter ), 会记录触发 exception 的那条指令的地址。</li></ul><p>Machine Mode 异常相关寄寄存器:</p><ul><li>类似于 Supervisor Mode， Machine Mode 也有相对应的寄存器，但由于本实验同学不需要操作这些寄存器，故不在此作介绍。</li></ul><p>以上寄存器的详细介绍请同学们参考 <a href="https://github.com/riscv/riscv-isa-manual/releases/download/Ratified-IMFDQC-and-Priv-v1.11/riscv-privileged-20190608.pdf">RISC-V Privileged Spec</a></p><h4 id="3-1-3-相关特权指令"><a href="#3-1-3-相关特权指令" class="headerlink" title="3.1.3 相关特权指令"></a>3.1.3 相关特权指令</h4><ul><li><code>ecall</code> ( Environment Call )，当我们在 S 态执行这条指令时，会触发一个 <code>ecall-from-s-mode-exception</code>，从而进入 M Mode 下的处理流程( 如设置定时器等 )；当我们在 U 态执行这条指令时，会触发一个 <code>ecall-from-u-mode-exception</code>，从而进入 S Mode 下的处理流程 ( 常用来进行系统调用 )。</li><li><code>sret</code> 用于 S 态 trap 返回, 通过 <code>sepc</code> 来设置 <code>pc</code> 的值， 返回到之前程序继续运行。</li></ul><p>以上指令的详细介绍请同学们参考 <a href="https://github.com/riscv/riscv-isa-manual/releases/download/Ratified-IMFDQC-and-Priv-v1.11/riscv-privileged-20190608.pdf">RISC-V Privileged Spec</a></p><h3 id="3-2-上下文处理"><a href="#3-2-上下文处理" class="headerlink" title="3.2 上下文处理"></a>3.2 上下文处理</h3><p>由于在处理 trap 时，有可能会改变系统的状态。所以在真正处理 trap 之前，我们有必要对系统的当前状态进行保存，在处理完成之后，我们再将系统恢复至原先的状态，就可以确保之前的程序继续正常运行。<br>这里的系统状态通常是指寄存器，这些寄存器也叫做CPU的上下文 ( <code>Context</code> ).</p><h3 id="3-3-trap-处理程序"><a href="#3-3-trap-处理程序" class="headerlink" title="3.3 trap 处理程序"></a>3.3 trap 处理程序</h3><p>trap 处理程序根据 <code>scause</code> 的值， 进入不同的处理逻辑，在本次试验中我们需要关心的只有 <code>Superviosr Timer Interrupt</code> 。</p><h3 id="3-4-时钟中断"><a href="#3-4-时钟中断" class="headerlink" title="3.4 时钟中断"></a>3.4 时钟中断</h3><p>时钟中断需要 CPU 硬件的支持。CPU 以“时钟周期”为工作的基本时间单位，对逻辑门的时序电路进行同步。而时钟中断实际上就是“每隔若干个时钟周期执行一次的程序”。下面介绍与时钟中断相关的寄存器以及如何产生时钟中断。</p><ul><li><code>mtime</code> 与 <code>mtimecmp</code> ( Machine Timer Register )。 <code>mtime</code> 是一个实时计时器， 由硬件以恒定的频率自增。<code>mtimecmp</code> 中保存着下一次时钟中断发生的时间点，当 <code>mtime</code> 的值大于或等于 <code>mtimecmp</code> 的值，系统就会触发一次时钟中断。因此我们只需要更新 <code>mtimecmp</code> 中的值，就可以设置下一次时钟中断的触发点。 <code>OpenSBI</code> 已经为我们提供了更新 <code>mtimecmp</code> 的接口 <code>sbi_set_timer</code> ( 见 <code>lab1</code> 4.4节 )。</li><li><code>mcounteren</code> ( Counter-Enable Registers )。由于 <code>mtime</code> 是属于 M 态的寄存器，我们在 S 态无法直接对其读写， 幸运的是 OpenSBI 在 M 态已经通过设置 <code>mcounteren</code> 寄存器的 <code>TM</code> 比特位， 让我们可以在 S 态中可以通过 <code>time</code> 这个<strong>只读</strong>寄存器读取到 <code>mtime</code>的当前值，相关汇编指令是 <code>rdtime</code>。</li></ul><p>以上寄存器的详细介绍请同学们参考 <a href="https://github.com/riscv/riscv-isa-manual/releases/download/Ratified-IMFDQC-and-Priv-v1.11/riscv-privileged-20190608.pdf">RISC-V Privileged Spec</a></p><h2 id="4-实验步骤"><a href="#4-实验步骤" class="headerlink" title="4 实验步骤"></a>4 实验步骤</h2><h3 id="4-1-准备工程"><a href="#4-1-准备工程" class="headerlink" title="4.1 准备工程"></a>4.1 准备工程</h3><ul><li><p>此次实验基于 lab1 同学所实现的代码进行。</p></li><li><p>在 <code>lab1</code> 中我们实现的 <code>puti</code> <code>puts</code> 使用起来较为繁琐，因此在这里我们提供了简化版的 <code>printk</code>。 从 <code>repo</code> 同步以下代码: <code>stddef.h</code> <code>printk.h</code> <code>printk.c</code>，并按如下目录结构放置。**还需要将之前所有 <code>print.h puti puts</code> 的引用修改为 <code>printk.h printk</code>**。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs stylus">.<br>├── Makefile<br>├── arch<br>├── include<br>│   ├── printk<span class="hljs-selector-class">.h</span><br>│   ├── stddef<span class="hljs-selector-class">.h</span><br>│   └── types<span class="hljs-selector-class">.h</span><br>├── init<br>└── lib<br>    ├── Makefile<br>    └── printk.c<br></code></pre></td></tr></table></figure></li><li><p>修改 <code>vmlinux.lds</code> 以及 <code>head.S</code></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs armasm">&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; 原先的 vmlinux.lds<br><span class="hljs-symbol">...</span><br><br><span class="hljs-symbol">.text</span> : <span class="hljs-meta">ALIGN</span>(<span class="hljs-number">0x1000</span>)&#123;<br>    _stext = .<span class="hljs-comment">;</span><br><br>    *(<span class="hljs-meta">.text</span>.entry)<br>    *(<span class="hljs-meta">.text</span> <span class="hljs-meta">.text</span>.*)<br>    <br>    _etext = .<span class="hljs-comment">;</span><br>&#125;<br><br><span class="hljs-symbol">...</span><br><br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 修改之后的 vmlinux.lds<br><span class="hljs-symbol">...</span><br><br><span class="hljs-symbol">.text</span> : <span class="hljs-meta">ALIGN</span>(<span class="hljs-number">0x1000</span>)&#123;<br>    _stext = .<span class="hljs-comment">;</span><br><br>    *(<span class="hljs-meta">.text</span>.init)      &lt;- 加入了 <span class="hljs-meta">.text</span>.init<br>    *(<span class="hljs-meta">.text</span>.entry)     &lt;- 之后我们实现 中断处理逻辑 会放置在 <span class="hljs-meta">.text</span>.entry<br>    *(<span class="hljs-meta">.text</span> <span class="hljs-meta">.text</span>.*)<br>    <br>    _etext = .<span class="hljs-comment">;</span><br>&#125;<br><br><span class="hljs-symbol">...</span><br></code></pre></td></tr></table></figure><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs stylus">&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; 原先的 head<span class="hljs-selector-class">.S</span><br>extern start_kernel<br><br>    <span class="hljs-selector-class">.section</span> <span class="hljs-selector-class">.text</span><span class="hljs-selector-class">.entry</span>        &lt;- 之前的 _start 放置在 <span class="hljs-selector-class">.text</span><span class="hljs-selector-class">.entry</span> <span class="hljs-selector-tag">section</span>       <br>    <span class="hljs-selector-class">.globl</span> _start<br>_start:<br>    ...<br><br>    <span class="hljs-selector-class">.section</span> <span class="hljs-selector-class">.bss</span><span class="hljs-selector-class">.stack</span><br>    <span class="hljs-selector-class">.globl</span> boot_stack<br>boot_stack:<br>    <span class="hljs-selector-class">.space</span> <span class="hljs-number">4096</span><br><br>    <span class="hljs-selector-class">.globl</span> boot_stack_top<br>boot_stack_top:<br><br>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 修改之后的 head<span class="hljs-selector-class">.S</span><br>extern start_kernel<br><br>    <span class="hljs-selector-class">.section</span> <span class="hljs-selector-class">.text</span><span class="hljs-selector-class">.init</span>         &lt;- 将 _start 放入<span class="hljs-selector-class">.text</span><span class="hljs-selector-class">.init</span> <span class="hljs-selector-tag">section</span> <br>    <span class="hljs-selector-class">.globl</span> _start<br>_start:<br>    ...<br><br>    <span class="hljs-selector-class">.section</span> <span class="hljs-selector-class">.bss</span><span class="hljs-selector-class">.stack</span><br>    <span class="hljs-selector-class">.globl</span> boot_stack<br>boot_stack:<br>    <span class="hljs-selector-class">.space</span> <span class="hljs-number">4096</span><br><br>    <span class="hljs-selector-class">.globl</span> boot_stack_top<br>boot_stack_top:<br></code></pre></td></tr></table></figure></li></ul><h3 id="4-2-开启-trap-处理"><a href="#4-2-开启-trap-处理" class="headerlink" title="4.2 开启 trap 处理"></a>4.2 开启 trap 处理</h3><p>在运行 <code>start_kernel</code> 之前，我们要对上面提到的 CSR 进行初始化，初始化包括以下几个步骤：</p><ol><li>设置 <code>stvec</code>， 将 <code>_traps</code> ( <code>_trap</code> 在 4.3 中实现 ) 所表示的地址写入 <code>stvec</code>，这里我们采用 <code>Direct 模式</code>, 而 <code>_traps</code> 则是 trap 处理入口函数的基地址。</li><li>开启时钟中断，将 <code>sie[STIE]</code> 置 1。</li><li>设置第一次时钟中断，参考 <code>clock_set_next_event()</code> ( <code>clock_set_next_event()</code> 在 4.5 中介绍 ) 中的逻辑用汇编实现。</li><li>开启 S 态下的中断响应， 将 <code>sstatus[SIE]</code> 置 1。</li></ol><p>按照下方模版修改 <code>arch/riscv/kernel/head.S</code>， 并补全 <code>_start</code> 中的逻辑。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs asm">.extern start_kernel<br><br>    .section .text.init<br>    .globl _start<br>_start:<br>    # YOUR CODE HERE<br><br>    # ------------------<br>        <br>        # set stvec = _traps<br>    <br>    # ------------------<br>    <br>        # set sie[STIE] = 1<br>    <br>    # ------------------<br>    <br>        # set first time interrupt<br>    <br>    # ------------------<br>    <br>        # set sstatus[SIE] = 1<br><br>    # ------------------<br>    <br>    # ------------------<br>    # - your lab1 code -<br>    # ------------------<br><br>    ...<br></code></pre></td></tr></table></figure><blockquote><p>Debug 提示：可以先不实现 stvec 和 first time interrupt，先关注 sie 和 sstatus 是否设置正确。</p></blockquote><h3 id="4-3-实现上下文切换"><a href="#4-3-实现上下文切换" class="headerlink" title="4.3 实现上下文切换"></a>4.3 实现上下文切换</h3><p>我们要使用汇编实现上下文切换机制， 包含以下几个步骤：</p><ol><li>在 <code>arch/riscv/kernel/</code> 目录下添加 <code>entry.S</code> 文件。</li><li>保存 CPU 的寄存器（上下文）到内存中（栈上）。</li><li>将 <code>scause</code> 和 <code>sepc</code> 中的值传入 trap 处理函数 <code>trap_handler</code> ( <code>trap_handler</code> 在 4.4 中介绍 ) ，我们将会在 <code>trap_handler</code> 中实现对 trap 的处理。</li><li>在完成对 trap 的处理之后， 我们从内存中（栈上）恢复CPU的寄存器（上下文）。</li><li>从 trap 中返回。</li></ol><p>按照下方模版修改 <code>arch/riscv/kernel/entry.S</code>， 并补全 <code>_traps</code> 中的逻辑。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs asm">    .section .text.entry<br>    .align 2<br>    .globl _traps <br>_traps:<br>    # YOUR CODE HERE<br>    # -----------<br><br>        # 1. save 32 registers and sepc to stack<br><br>    # -----------<br><br>        # 2. call trap_handler<br><br>    # -----------<br><br>        # 3. restore sepc and 32 registers (x2(sp) should be restore last) from stack<br><br>    # -----------<br><br>        # 4. return from trap<br><br>    # -----------<br></code></pre></td></tr></table></figure><blockquote><p>Debug 提示： 可以先不实现 call trap_handler， 先实现上下文切换逻辑。通过 gdb 跟踪各个寄存器，确保上下文的 save 与 restore 正确实现并正确返回。</p></blockquote><h3 id="4-4-实现-trap-处理函数"><a href="#4-4-实现-trap-处理函数" class="headerlink" title="4.4 实现 trap 处理函数"></a>4.4 实现 trap 处理函数</h3><ol><li>在 <code>arch/riscv/kernel/</code> 目录下添加 <code>trap.c</code> 文件。</li><li>在 <code>trap.c</code> 中实现 trap 处理函数 <code>trap_handler()</code>, 其接收的两个参数分别是 <code>scause</code> 和 <code>sepc</code> 两个寄存器中的值。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// trap.c </span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">trap_handler</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> scause, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sepc)</span> &#123;<br>    <span class="hljs-comment">// 通过 `scause` 判断trap类型</span><br>    <span class="hljs-comment">// 如果是interrupt 判断是否是timer interrupt</span><br>    <span class="hljs-comment">// 如果是timer interrupt 则打印输出相关信息, 并通过 `clock_set_next_event()` 设置下一次时钟中断</span><br>    <span class="hljs-comment">// `clock_set_next_event()` 见 4.5 节</span><br>    <span class="hljs-comment">// 其他interrupt / exception 可以直接忽略</span><br>    <br>    <span class="hljs-comment">// YOUR CODE HERE</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-5-实现时钟中断相关函数"><a href="#4-5-实现时钟中断相关函数" class="headerlink" title="4.5 实现时钟中断相关函数"></a>4.5 实现时钟中断相关函数</h3><ol><li>在 <code>arch/riscv/kernel/</code> 目录下添加 <code>clock.c</code> 文件。</li><li>在 <code>clock.c</code> 中实现 get_cycles ( ) : 使用 <code>rdtime</code> 汇编指令获得当前 <code>time</code> 寄存器中的值。</li><li>在 <code>clock.c</code> 中实现 clock_set_next_event ( ) : 调用 <code>sbi_ecall</code>，设置下一个时钟中断事件。</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// clock.c</span><br><br><span class="hljs-comment">// QEMU中时钟的频率是10MHz, 也就是1秒钟相当于10000000个时钟周期。</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> TIMECLOCK = <span class="hljs-number">10000000</span>;<br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-title function_">get_cycles</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 编写内联汇编，使用 rdtime 获取 time 寄存器中 (也就是mtime 寄存器 )的值并返回</span><br>    <span class="hljs-comment">// YOUR CODE HERE</span><br><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">clock_set_next_event</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 下一次 时钟中断 的时间点</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> next = get_cycles() + TIMECLOCK;<br><br>    <span class="hljs-comment">// 使用 sbi_ecall 来完成对下一次时钟中断的设置</span><br>    <span class="hljs-comment">// YOUR CODE HERE</span><br>&#125; <br><br></code></pre></td></tr></table></figure><h3 id="4-6-编译及测试"><a href="#4-6-编译及测试" class="headerlink" title="4.6 编译及测试"></a>4.6 编译及测试</h3><p>由于加入了一些新的 .c 文件，可能需要修改一些Makefile文件，请同学自己尝试修改，使项目可以编译并运行。</p><p>下面是一个正确实现的输出样例。（ 仅供参考 ）</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">kernel</span> <span class="hljs-variable">is</span> <span class="hljs-variable">running</span><span class="hljs-operator">!</span><br><span class="hljs-punctuation">[</span><span class="hljs-variable">S</span><span class="hljs-punctuation">]</span> <span class="hljs-variable">Supervisor</span> <span class="hljs-built_in">Mode</span> <span class="hljs-variable">Timer</span> <span class="hljs-built_in">Interrupt</span><br><span class="hljs-variable">kernel</span> <span class="hljs-variable">is</span> <span class="hljs-variable">running</span><span class="hljs-operator">!</span><br><span class="hljs-punctuation">[</span><span class="hljs-variable">S</span><span class="hljs-punctuation">]</span> <span class="hljs-variable">Supervisor</span> <span class="hljs-built_in">Mode</span> <span class="hljs-variable">Timer</span> <span class="hljs-built_in">Interrupt</span><br><span class="hljs-variable">kernel</span> <span class="hljs-variable">is</span> <span class="hljs-variable">running</span><span class="hljs-operator">!</span><br><span class="hljs-punctuation">[</span><span class="hljs-variable">S</span><span class="hljs-punctuation">]</span> <span class="hljs-variable">Supervisor</span> <span class="hljs-built_in">Mode</span> <span class="hljs-variable">Timer</span> <span class="hljs-built_in">Interrupt</span><br><span class="hljs-variable">kernel</span> <span class="hljs-variable">is</span> <span class="hljs-variable">running</span><span class="hljs-operator">!</span><br><span class="hljs-punctuation">[</span><span class="hljs-variable">S</span><span class="hljs-punctuation">]</span> <span class="hljs-variable">Supervisor</span> <span class="hljs-built_in">Mode</span> <span class="hljs-variable">Timer</span> <span class="hljs-built_in">Interrupt</span><br><span class="hljs-variable">kernel</span> <span class="hljs-variable">is</span> <span class="hljs-variable">running</span><span class="hljs-operator">!</span><br><span class="hljs-punctuation">[</span><span class="hljs-variable">S</span><span class="hljs-punctuation">]</span> <span class="hljs-variable">Supervisor</span> <span class="hljs-built_in">Mode</span> <span class="hljs-variable">Timer</span> <span class="hljs-built_in">Interrupt</span><br><span class="hljs-variable">kernel</span> <span class="hljs-variable">is</span> <span class="hljs-variable">running</span><span class="hljs-operator">!</span><br><span class="hljs-punctuation">[</span><span class="hljs-variable">S</span><span class="hljs-punctuation">]</span> <span class="hljs-variable">Supervisor</span> <span class="hljs-built_in">Mode</span> <span class="hljs-variable">Timer</span> <span class="hljs-built_in">Interrupt</span><br><span class="hljs-variable">kernel</span> <span class="hljs-variable">is</span> <span class="hljs-variable">running</span><span class="hljs-operator">!</span><br><span class="hljs-punctuation">[</span><span class="hljs-variable">S</span><span class="hljs-punctuation">]</span> <span class="hljs-variable">Supervisor</span> <span class="hljs-built_in">Mode</span> <span class="hljs-variable">Timer</span> <span class="hljs-built_in">Interrupt</span><br><span class="hljs-variable">kernel</span> <span class="hljs-variable">is</span> <span class="hljs-variable">running</span><span class="hljs-operator">!</span><br><span class="hljs-punctuation">[</span><span class="hljs-variable">S</span><span class="hljs-punctuation">]</span> <span class="hljs-variable">Supervisor</span> <span class="hljs-built_in">Mode</span> <span class="hljs-variable">Timer</span> <span class="hljs-built_in">Interrupt</span><br><span class="hljs-variable">kernel</span> <span class="hljs-variable">is</span> <span class="hljs-variable">running</span><span class="hljs-operator">!</span><br><span class="hljs-punctuation">[</span><span class="hljs-variable">S</span><span class="hljs-punctuation">]</span> <span class="hljs-variable">Supervisor</span> <span class="hljs-built_in">Mode</span> <span class="hljs-variable">Timer</span> <span class="hljs-built_in">Interrupt</span><br></code></pre></td></tr></table></figure><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><ol><li>在我们使用make run时， OpenSBI 会产生如下输出:</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plaintext"> OpenSBI v0.9<br>  ____                    _____ ____ _____<br> / __ \                  / ____|  _ \_   _|<br>| |  | |_ __   ___ _ __ | (___ | |_) || |<br>| |  | | &#x27;_ \ / _ \ &#x27;_ \ \___ \|  _ &lt; | |<br>| |__| | |_) |  __/ | | |____) | |_) || |_<br> \____/| .__/ \___|_| |_|_____/|____/_____|<br>       | |<br>       |_|<br><br> ......<br><br> Boot HART MIDELEG         : 0x0000000000000222<br> Boot HART MEDELEG         : 0x000000000000b109<br><br> ......<br></code></pre></td></tr></table></figure><pre><code class="hljs">通过查看 `RISC-V Privileged Spec` 中的 `medeleg` 和 `mideleg` 解释上面 `MIDELEG` 值的含义。</code></pre><h2 id="作业提交"><a href="#作业提交" class="headerlink" title="作业提交"></a>作业提交</h2><p>同学需要提交实验报告以及整个工程代码。在提交前请使用 <code>make clean</code> 清除所有构建产物。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="操作系统" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="os实验文档" scheme="http://example.com/tags/os%E5%AE%9E%E9%AA%8C%E6%96%87%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title>oslab1</title>
    <link href="http://example.com/2023/07/08/oslab1/"/>
    <id>http://example.com/2023/07/08/oslab1/</id>
    <published>2023-07-08T06:43:00.000Z</published>
    <updated>2023-07-29T05:52:30.885Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Lab-1-RV64-内核引导"><a href="#Lab-1-RV64-内核引导" class="headerlink" title="Lab 1: RV64 内核引导"></a>Lab 1: RV64 内核引导</h1><h2 id="1-实验目的"><a href="#1-实验目的" class="headerlink" title="1 实验目的"></a>1 实验目的</h2><ul><li>学习 RISC-V 汇编， 编写 head.S 实现跳转到内核运行的第一个 C 函数。</li><li>学习 OpenSBI，理解 OpenSBI 在实验中所起到的作用，并调用 OpenSBI 提供的接口完成字符的输出。</li><li>学习 Makefile 相关知识， 补充项目中的 Makefile 文件， 来完成对整个工程的管理。</li></ul><h2 id="2-实验环境"><a href="#2-实验环境" class="headerlink" title="2 实验环境"></a>2 实验环境</h2><ul><li>Environment in Lab0</li></ul><h2 id="3-实验基础知识介绍"><a href="#3-实验基础知识介绍" class="headerlink" title="3 实验基础知识介绍"></a>3 实验基础知识介绍</h2><h3 id="3-1-前置知识"><a href="#3-1-前置知识" class="headerlink" title="3.1 前置知识"></a>3.1 前置知识</h3><p>为了顺利完成 OS 实验，我们需要一些前置知识和较多调试技巧。在 OS 实验中我们需要 <strong>RISC-V汇编</strong> 的前置知识，课堂上不会讲授，请同学们通过阅读以下四份文档自学：</p><ul><li><a href="https://github.com/riscv-non-isa/riscv-asm-manual/blob/master/riscv-asm.md">RISC-V Assembly Programmer’s Manual</a></li><li><a href="https://github.com/riscv/riscv-isa-manual/releases/download/Ratified-IMAFDQC/riscv-spec-20191213.pdf">RISC-V Unprivileged Spec</a></li><li><a href="https://github.com/riscv/riscv-isa-manual/releases/download/Priv-v1.12/riscv-privileged-20211203.pdf">RISC-V Privileged Spec</a></li><li><a href="http://riscvbook.com/chinese/RISC-V-Reader-Chinese-v2p1.pdf">RISC-V 手册（中文）</a></li></ul><blockquote><p>注：RISC-V 手册（中文）中有一些 Typo，请谨慎参考。</p></blockquote><h3 id="3-2-RISC-V-的三种特权模式"><a href="#3-2-RISC-V-的三种特权模式" class="headerlink" title="3.2 RISC-V 的三种特权模式"></a>3.2 RISC-V 的三种特权模式</h3><p>RISC-V 有三个特权模式：U (user) 模式、S (supervisor) 模式和 M (machine) 模式。</p><table><thead><tr><th>Level</th><th>Encoding</th><th>Name</th><th>Abbreviation</th></tr></thead><tbody><tr><td>0</td><td>00</td><td>User&#x2F;Application</td><td>U</td></tr><tr><td>1</td><td>01</td><td>Supervisor</td><td>S</td></tr><tr><td>2</td><td>10</td><td>Reserved</td><td></td></tr><tr><td>3</td><td>11</td><td>Machine</td><td>M</td></tr></tbody></table><p>其中：</p><ul><li>M 模式是对硬件操作的抽象，有<strong>最高</strong>级别的权限</li><li>S 模式介于 M 模式和 U 模式之间，在操作系统中对应于内核态 (Kernel)。当用户需要内核资源时，向内核申请，并切换到内核态进行处理</li><li>U 模式用于执行用户程序，在操作系统中对应于用户态，有<strong>最低</strong>级别的权限</li></ul><h3 id="3-3-从计算机上电到-OS-运行"><a href="#3-3-从计算机上电到-OS-运行" class="headerlink" title="3.3 从计算机上电到 OS 运行"></a>3.3 从计算机上电到 OS 运行</h3><p>我们以最基础的嵌入式系统为例，计算机上电后，首先硬件进行一些基础的初始化后，将 CPU 的 Program Counter 移动到内存中 Bootloader 的起始地址。<br>Bootloader 是操作系统内核运行之前，用于初始化硬件，加载操作系统内核。<br>在 RISC-V 架构里，Bootloader 运行在 M 模式下。Bootloader 运行完毕后就会把当前模式切换到 S 模式下，机器随后开始运行 Kernel。</p><p>这个过程简单而言就是这样：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">   Hardware             RISC-V M Mode           RISC-V S Mode <br>+<span class="hljs-params">------------</span>+         +<span class="hljs-params">--------------</span>+         +<span class="hljs-params">----------</span>+<br>|  Power On  |  <span class="hljs-params">----</span>&gt;  |  Bootloader  |  <span class="hljs-params">----</span>&gt;  |  Kernel  |<br>+<span class="hljs-params">------------</span>+         +<span class="hljs-params">--------------</span>+         +<span class="hljs-params">----------</span>+<br></code></pre></td></tr></table></figure><h3 id="3-4-SBI-与-OpenSBI"><a href="#3-4-SBI-与-OpenSBI" class="headerlink" title="3.4 SBI 与 OpenSBI"></a>3.4 SBI 与 OpenSBI</h3><p>SBI (Supervisor Binary Interface) 是 S-mode 的 Kernel 和 M-mode 执行环境之间的接口规范，而 OpenSBI 是一个 RISC-V SBI 规范的开源实现。RISC-V 平台和 SoC 供应商可以自主扩展 OpenSBI 实现，以适应特定的硬件配置。</p><p>简单的说，为了使操作系统内核适配不同硬件，OpenSBI 提出了一系列规范对 M-mode 下的硬件进行了统一定义，运行在 S-mode 下的内核可以按照这些规范对不同硬件进行操作。</p><p><img src="C:/Users/LEGION/Desktop/zju/软工/专业课/os/labsrc/os22fall-stu/docs/img/riscv-sbi.png" alt="RISC-V SBI 介绍"></p><p>为降低实验难度，我们选择 OpenSBI 作为 Bootloader 来完成机器启动时 M-mode 下的硬件初始化与寄存器设置，并使用 OpenSBI 所提供的接口完成诸如字符打印的操作。</p><p>在实验中，QEMU 已经内置了 OpenSBI 作为 Bootloader，我们可以使用 <code>-bios default</code> 启用。如果启用，QEMU 会将 OpenSBI 代码加载到 0x80000000 起始处。OpenSBI 初始化完成后，会跳转到 0x80200000 处（也就是 Kernel 的起始地址）。因此，我们所编译的代码需要放到 0x80200000 处。</p><p>如果你对 RISC-V 架构的 Boot 流程有更多的好奇，可以参考这份 <a href="https://riscv.org/wp-content/uploads/2019/12/Summit_bootflow.pdf">bootflow</a>。</p><h3 id="3-5-Makefile"><a href="#3-5-Makefile" class="headerlink" title="3.5 Makefile"></a>3.5 Makefile</h3><p>Makefile 可以简单的认为是一个工程文件的编译规则，描述了整个工程的编译和链接流程。在 Lab0 中我们已经使用了 make 工具利用 Makefile 文件来管理整个工程。在阅读了 <a href="https://seisman.github.io/how-to-write-makefile/introduction.html">Makefile介绍</a> 这一章节后，同学们可以根据工程文件夹里 Makefile 的代码来掌握一些基本的使用技巧。</p><h3 id="3-6-内联汇编"><a href="#3-6-内联汇编" class="headerlink" title="3.6 内联汇编"></a>3.6 内联汇编</h3><p>内联汇编（通常由 asm 或者 __asm__ 关键字引入）提供了将汇编语言源代码嵌入 C 程序的能力。<br>内联汇编的详细介绍请参考 <a href="https://gcc.gnu.org/onlinedocs/gcc/Extended-Asm.html">Assembler Instructions with C Expression Operands</a> 。<br>下面简要介绍一下这次实验会用到的一些内联汇编知识：</p><p>内联汇编基本格式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">__asm__ <span class="hljs-title function_">volatile</span> <span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-string">&quot;instruction1\n&quot;</span></span><br><span class="hljs-params">    <span class="hljs-string">&quot;instruction2\n&quot;</span></span><br><span class="hljs-params">    ......</span><br><span class="hljs-params">    ......</span><br><span class="hljs-params">    <span class="hljs-string">&quot;instruction3\n&quot;</span></span><br><span class="hljs-params">    : [out1] <span class="hljs-string">&quot;=r&quot;</span> (v1),[out2] <span class="hljs-string">&quot;=r&quot;</span> (v2)</span><br><span class="hljs-params">    : [in1] <span class="hljs-string">&quot;r&quot;</span> (v1), [in2] <span class="hljs-string">&quot;r&quot;</span> (v2)</span><br><span class="hljs-params">    : <span class="hljs-string">&quot;memory&quot;</span></span><br><span class="hljs-params">)</span>;<br></code></pre></td></tr></table></figure><p>其中，三个 <code>:</code> 将汇编部分分成了四部分：</p><ul><li>第一部分是汇编指令，指令末尾需要添加 ‘\n’。</li><li>第二部分是输出操作数部分。</li><li>第三部分是输入操作数部分。</li><li>第四部分是可能影响的寄存器或存储器，用于告知编译器当前内联汇编语句可能会对某些寄存器或内存进行修改，使得编译器在优化时将其因素考虑进去。</li></ul><p>这四部分中后三部分不是必须的。</p><h4 id="示例一"><a href="#示例一" class="headerlink" title="示例一"></a>示例一</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title function_">s_example</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> type,<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> arg0)</span> &#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> ret_val;<br>    __asm__ <span class="hljs-title function_">volatile</span> <span class="hljs-params">(</span><br><span class="hljs-params">        <span class="hljs-string">&quot;mv x10, %[type]\n&quot;</span></span><br><span class="hljs-params">        <span class="hljs-string">&quot;mv x11, %[arg0]\n&quot;</span></span><br><span class="hljs-params">        <span class="hljs-string">&quot;mv %[ret_val], x12&quot;</span></span><br><span class="hljs-params">        : [ret_val] <span class="hljs-string">&quot;=r&quot;</span> (ret_val)</span><br><span class="hljs-params">        : [type] <span class="hljs-string">&quot;r&quot;</span> (type), [arg0] <span class="hljs-string">&quot;r&quot;</span> (arg0)</span><br><span class="hljs-params">        : <span class="hljs-string">&quot;memory&quot;</span></span><br><span class="hljs-params">    )</span>;<br>    <span class="hljs-keyword">return</span> ret_val;<br>&#125;<br></code></pre></td></tr></table></figure><p>示例一中指令部分，<code>%[type]</code>、<code>%[arg0]</code> 以及 <code>%[ret_val]</code> 代表着特定的寄存器或是内存。</p><p>输入输出部分中，<code>[type] &quot;r&quot; (type)</code>代表着将 <code>()</code> 中的变量 <code>type</code> 放入寄存器中（<code>&quot;r&quot;</code> 指放入寄存器，如果是 <code>&quot;m&quot;</code> 则为放入内存），并且绑定到 <code>[]</code> 中命名的符号中去。<code>[ret_val] &quot;=r&quot; (ret_val)</code> 代表着将汇编指令中 <code>%[ret_val]</code> 的值更新到变量 <code>ret_val</code>中。</p><h4 id="示例二"><a href="#示例二" class="headerlink" title="示例二"></a>示例二</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> write_csr(reg, val) (&#123;</span><br>    __asm__ <span class="hljs-title function_">volatile</span> <span class="hljs-params">(<span class="hljs-string">&quot;csrw &quot;</span> #reg <span class="hljs-string">&quot;, %0&quot;</span> :: <span class="hljs-string">&quot;r&quot;</span>(val))</span>; &#125;)<br></code></pre></td></tr></table></figure><p>示例二定义了一个宏，其中 <code>%0</code> 代表着输出输入部分的第一个符号，即 <code>val</code>。</p><p><code>#reg</code> 是c语言的一个特殊宏定义语法，相当于将reg进行宏替换并用双引号包裹起来。</p><p>例如 <code>write_csr(sstatus,val)</code> 经宏展开会得到：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">(&#123;<br>    __asm__ <span class="hljs-keyword">volatile</span> (<span class="hljs-string">&quot;csrw &quot;</span> <span class="hljs-string">&quot;sstatus&quot;</span> <span class="hljs-string">&quot;, %0&quot;</span> :: <span class="hljs-string">&quot;r&quot;</span>(val)); &#125;)<br></code></pre></td></tr></table></figure><h3 id="3-7-编译相关知识介绍"><a href="#3-7-编译相关知识介绍" class="headerlink" title="3.7 编译相关知识介绍"></a>3.7 编译相关知识介绍</h3><h4 id="vmlinux-lds"><a href="#vmlinux-lds" class="headerlink" title="vmlinux.lds"></a>vmlinux.lds</h4><p>GNU ld 即链接器，用于将 <code>*.o</code> 文件（和库文件）链接成可执行文件。在操作系统开发中，为了指定程序的内存布局，ld 使用链接脚本（Linker Script）来控制，在 Linux Kernel 中链接脚本被命名为 vmlinux.lds。更多关于 ld 的介绍可以使用 <code>man ld</code> 命令。</p><p>下面给出一个 vmlinux.lds 的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs lds">/* 目标架构 */<br>OUTPUT_ARCH( &quot;riscv&quot; )<br><br>/* 程序入口 */<br>ENTRY( _start )<br><br>/* kernel代码起始位置 */<br>BASE_ADDR = 0x80200000;<br><br>SECTIONS<br>&#123;<br>    /* . 代表当前地址 */<br>    . = BASE_ADDR;<br><br>    /* 记录kernel代码的起始地址 */<br>    _skernel = .;<br><br>    /* ALIGN(0x1000) 表示4KB对齐 */<br>    /* _stext, _etext 分别记录了text段的起始与结束地址 */<br>    .text : ALIGN(0x1000)&#123;<br>        _stext = .;<br><br>        *(.text.entry)<br>        *(.text .text.*)<br>        <br>        _etext = .;<br>    &#125;<br><br>    .rodata : ALIGN(0x1000)&#123;<br>        _srodata = .;<br><br>        *(.rodata .rodata.*)<br>        <br>        _erodata = .;<br>    &#125;<br><br>    .data : ALIGN(0x1000)&#123;<br>        _sdata = .;<br><br>        *(.data .data.*)<br>        <br>        _edata = .;<br>    &#125;<br><br>    .bss : ALIGN(0x1000)&#123;<br>        _sbss = .;<br><br>        *(.bss.stack)<br>        sbss = .;<br>        *(.bss .bss.*)<br>        <br>        _ebss = .;<br>    &#125;<br><br>    /* 记录kernel代码的结束地址 */<br>    _ekernel = .;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先我们使用 OUTPUT_ARCH 指定了架构为 RISC-V ，之后使用 ENTRY 指定程序入口点为 <code>_start</code> 函数，程序入口点即程序启动时运行的函数，经过这样的指定后在head.S中需要编写 <code>_start</code> 函数，程序才能正常运行。</p><p>链接脚本中有<code>.</code> <code>*</code>两个重要的符号。单独的<code>.</code>在链接脚本代表当前地址，它有赋值、被赋值、自增等操作。而<code>*</code>有两种用法，其一是<code>*()</code>在大括号中表示将所有文件中符合括号内要求的段放置在当前位置，其二是作为通配符。</p><p>链接脚本的主体是SECTIONS部分，在这里链接脚本的工作是将程序的各个段按顺序放在各个地址上，在例子中就是从0x80200000地址开始放置了 <code>.text</code> ， <code>.rodata</code> ， <code>.data</code> 和 <code>.bss</code> 段。各个段的作用可以简要概括成：</p><table><thead><tr><th>段名</th><th>主要作用</th></tr></thead><tbody><tr><td>.text</td><td>通常存放程序执行代码</td></tr><tr><td>.rodata</td><td>通常存放常量等只读数据</td></tr><tr><td>.data</td><td>通常存放已初始化的全局变量、静态变量</td></tr><tr><td>.bss</td><td>通常存放未初始化的全局变量、静态变量</td></tr></tbody></table><p>在链接脚本中可以自定义符号，例如以上所有 <code>_s</code> 与  <code>_e</code>开头的符号都是我们自己定义的。</p><p>更多有关链接脚本语法可以参考<a href="https://sourceware.org/binutils/docs/ld/Scripts.html">这里</a>。</p><h4 id="vmlinux"><a href="#vmlinux" class="headerlink" title="vmlinux"></a>vmlinux</h4><p>vmlinux 通常指 Linux Kernel 编译出的可执行文件 (Executable and Linkable Format &#x2F; ELF)，特点是未压缩的，带调试信息和符号表的。在整套 OS 实验中，vmlinux 通常指将你的代码进行编译，链接后生成的可供 QEMU 运行的 RV64 架构程序。如果对 vmlinux 使用 <code>file</code> 命令，你将看到如下信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ file vmlinux <br>vmlinux: ELF 64-bit LSB executable, UCB RISC-V, version 1 (SYSV), statically linked, not stripped<br></code></pre></td></tr></table></figure><h4 id="System-map"><a href="#System-map" class="headerlink" title="System.map"></a>System.map</h4><p>System.map是内核符号表（Kernel Symbol Table）文件，是存储了所有内核符号及其地址的一个列表。“符号”通常指的是函数名，全局变量名等等。使用 <code>nm vmlinux</code> 命令即可打印vmlinux的符号表，符号表的样例如下：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">0000000000000800</span> <span class="hljs-keyword">A</span> __vdso_rt_sigreturn<br>ffffffe<span class="hljs-number">000000000</span> T __init_begin<br>ffffffe<span class="hljs-number">000000000</span> T _sinittext<br>ffffffe<span class="hljs-number">000000000</span> T _start<br>ffffffe<span class="hljs-number">000000040</span> T _start_kernel<br>ffffffe<span class="hljs-number">000000076</span> t clear_bss<br>ffffffe<span class="hljs-number">000000080</span> t clear_bss_done<br>ffffffe<span class="hljs-number">0000000c0</span> t relocate<br>ffffffe00000017c t set_reset_devices<br>ffffffe<span class="hljs-number">000000190</span> t debug_kernel<br></code></pre></td></tr></table></figure><p>使用 System.map 可以方便地读出函数或变量的地址，为 Debug 提供了方便。</p><h2 id="4-实验步骤"><a href="#4-实验步骤" class="headerlink" title="4 实验步骤"></a>4 实验步骤</h2><h3 id="4-1-准备工程"><a href="#4-1-准备工程" class="headerlink" title="4.1 准备工程"></a>4.1 准备工程</h3><p>从 <a href="https://github.com/ZJU-SEC/os22fall-stu">repo</a> 同步实验代码框架。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs stylus">├── arch<br>│   └── riscv<br>│       ├── include<br>│       │   ├── defs<span class="hljs-selector-class">.h</span><br>│       │   └── sbi<span class="hljs-selector-class">.h</span><br>│       ├── kernel<br>│       │   ├── head<span class="hljs-selector-class">.S</span><br>│       │   ├── Makefile<br>│       │   ├── sbi<span class="hljs-selector-class">.c</span><br>│       │   └── vmlinux<span class="hljs-selector-class">.lds</span><br>│       └── Makefile<br>├── include<br>│   ├── print<span class="hljs-selector-class">.h</span><br>│   └── types<span class="hljs-selector-class">.h</span><br>├── init<br>│   ├── <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span><br>│   ├── Makefile<br>│   └── test<span class="hljs-selector-class">.c</span><br>├── lib<br>│   ├── Makefile<br>│   └── print<span class="hljs-selector-class">.c</span><br>└── Makefile<br></code></pre></td></tr></table></figure><p>需要完善以下文件：</p><ul><li>arch&#x2F;riscv&#x2F;kernel&#x2F;head.S</li><li>lib&#x2F;Makefile</li><li>arch&#x2F;riscv&#x2F;kernel&#x2F;sbi.c</li><li>lib&#x2F;print.c</li><li>arch&#x2F;riscv&#x2F;include&#x2F;defs.h</li></ul><h3 id="4-2-编写head-S"><a href="#4-2-编写head-S" class="headerlink" title="4.2 编写head.S"></a>4.2 编写head.S</h3><p>学习riscv的汇编。</p><p>完成 arch&#x2F;riscv&#x2F;kernel&#x2F;head.S 。我们首先为即将运行的第一个 C 函数设置程序栈（栈的大小可以设置为4KB），并将该栈放置在<code>.bss.stack</code> 段。接下来我们只需要通过跳转指令，跳转至 main.c 中的 <code>start_kernel</code> 函数即可。</p><h3 id="4-3-完善-Makefile-脚本"><a href="#4-3-完善-Makefile-脚本" class="headerlink" title="4.3 完善 Makefile 脚本"></a>4.3 完善 Makefile 脚本</h3><p>阅读文档中关于 <a href="#35-makefile">Makefile</a> 的章节，以及工程文件中的 Makefile 文件，根据注释学会 Makefile 的使用规则后，补充 <code>lib/Makefile</code>，使工程得以编译。  </p><p>完成此步后在工程根文件夹执行 make，可以看到工程成功编译出 vmlinux。</p><h3 id="4-4-补充-sbi-c"><a href="#4-4-补充-sbi-c" class="headerlink" title="4.4 补充 sbi.c"></a>4.4 补充 <code>sbi.c</code></h3><p>OpenSBI 在 M 态，为 S 态提供了多种接口，比如字符串输入输出。因此我们需要实现调用 OpenSBI 接口的功能。给出函数定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sbiret</span> &#123;</span><br><span class="hljs-type">long</span> error;<br><span class="hljs-type">long</span> value;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> sbiret <span class="hljs-title function_">sbi_ecall</span><span class="hljs-params">(<span class="hljs-type">int</span> ext, <span class="hljs-type">int</span> fid, </span><br><span class="hljs-params">                    uint64 arg0, uint64 arg1, uint64 arg2,</span><br><span class="hljs-params">                    uint64 arg3, uint64 arg4, uint64 arg5)</span>;<br></code></pre></td></tr></table></figure><p>sbi_ecall 函数中，需要完成以下内容：</p><ol><li>将 ext (Extension ID) 放入寄存器 a7 中，fid (Function ID) 放入寄存器 a6 中，将 arg0 ~ arg5 放入寄存器 a0 ~ a5 中。</li><li>使用 <code>ecall</code> 指令。<code>ecall</code> 之后系统会进入 M 模式，之后 OpenSBI 会完成相关操作。</li><li>OpenSBI 的返回结果会存放在寄存器 a0 ， a1 中，其中 a0 为 error code， a1 为返回值， 我们用 sbiret 来接受这两个返回值。</li></ol><p>同学们可以参照内联汇编的示例一完成该函数的编写。<br>编写成功后，调用 <code>sbi_ecall(0x1, 0x0, 0x30, 0, 0, 0, 0, 0)</code> 将会输出字符’0’。其中<code>0x1</code>代表 <code>sbi_console_putchar</code> 的 ExtensionID，<code>0x0</code>代表FunctionID, 0x30代表’0’的ascii值，其余参数填0。</p><p>请在 <code>arch/riscv/kernel/sbi.c</code> 中补充 <code>sbi_ecall()</code>。</p><p>下面列出了一些在后续的实验中可能需要使用的功能。</p><table><thead><tr><th>Function Name</th><th>Function ID</th><th>Extension ID</th></tr></thead><tbody><tr><td>sbi_set_timer （设置时钟相关寄存器）</td><td>0</td><td>0x00</td></tr><tr><td>sbi_console_putchar （打印字符）</td><td>0</td><td>0x01</td></tr><tr><td>sbi_console_getchar （接收字符）</td><td>0</td><td>0x02</td></tr></tbody></table><p>|sbi_shutdown （关机）|0|0x08| 下面是实验指导中一些有用的信息：</p><h3 id="4-5-puts-和-puti"><a href="#4-5-puts-和-puti" class="headerlink" title="4.5 puts() 和 puti()"></a>4.5 <code>puts()</code> 和 <code>puti()</code></h3><p>调用以上完成的 <code>sbi_ecall</code> , 完成 <code>puts()</code> 和 <code>puti()</code> 的实现。<br><code>puts()</code> 用于打印字符串，<code>puti()</code> 用于打印整型变量。</p><p>请编写 <code>lib/print.c</code> 中的 <code>puts()</code> 和 <code>puti()</code>， 函数的相关定义已经写在了 <code>print.h</code> 文件。</p><h3 id="4-6-修改-defs"><a href="#4-6-修改-defs" class="headerlink" title="4.6 修改 defs"></a>4.6 修改 defs</h3><p>内联汇编的相关知识见<a href="#36">内联汇编</a>。 </p><p>学习了解了以上知识后，补充 <code>arch/riscv/include/defs.h</code> 中的代码完成：</p><p>补充完 <code>read_csr</code> 这个宏定义。这里有相关<a href="#_2">示例</a>。</p><h2 id="5-其他架构的交叉编译——以-Aarch64-为例"><a href="#5-其他架构的交叉编译——以-Aarch64-为例" class="headerlink" title="5 其他架构的交叉编译——以 Aarch64 为例"></a>5 其他架构的交叉编译——以 Aarch64 为例</h2><h3 id="5-1-交叉编译工具链的安装"><a href="#5-1-交叉编译工具链的安装" class="headerlink" title="5.1 交叉编译工具链的安装"></a>5.1 交叉编译工具链的安装</h3><p>那么如何安装不同架构的交叉编译工具链呢？最简单的方法是用 Ubuntu 自带的软件包管理器 <code>apt</code>，先找到有什么交叉编译工具可以装</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-comment"># 搜索包含 aarch64 的软件包，一般是交叉编译工具</span><br>apt-<span class="hljs-keyword">cache </span>search aarch64<br>...<br><span class="hljs-comment"># 搜索结果中如果有 gcc-xxx-linux-gnu，一般需求下装它就行了（具体情况具体分析哈）</span><br>sudo apt <span class="hljs-keyword">install </span>gcc-aarch64-linux-gnu<br></code></pre></td></tr></table></figure><p>现在我们有 aarch64 的交叉编译工具链了，开始编译吧！</p><h3 id="5-2-怎么获得编译过程的中间产物"><a href="#5-2-怎么获得编译过程的中间产物" class="headerlink" title="5.2 怎么获得编译过程的中间产物"></a>5.2 怎么获得编译过程的中间产物</h3><p><strong>注意：这里说的“编译过程”包括预处理、编译、汇编、链接</strong></p><p>对于 Linux kernel，编译命令和选项在不同架构之间都大同小异，一般遵循以下形式（类比 lab0 做过的 riscv64 即可）</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">make <span class="hljs-attribute">ARCH</span>=xxx <span class="hljs-attribute">CROSS_COMPILE</span>=some-certain-arch- &lt;options&gt; &lt;files&gt;<br></code></pre></td></tr></table></figure><p>比如，想获得 kernel 中 <code>xxx.c</code> 的预处理产物（回忆一下预处理做了什么）<code>xxx.i</code>，我们可以</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 先 config</span><br>make <span class="hljs-attribute">ARCH</span>=arm64 <span class="hljs-attribute">CROSS_COMPILE</span>=aarch64-linux-gnu- defconfig<br><br><span class="hljs-comment"># 然后指定要生成的文件</span><br>make <span class="hljs-attribute">ARCH</span>=arm64 <span class="hljs-attribute">CROSS_COMPILE</span>=aarch64-linux-gnu- path/<span class="hljs-keyword">to</span>/file/xxx.i<br></code></pre></td></tr></table></figure><p>课件里也给出了 <code>make</code> 工具。</p><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><ol><li><p>请总结一下 RISC-V 的 calling convention，并解释 Caller &#x2F; Callee Saved Register 有什么区别？</p></li><li><p>编译之后，通过 System.map 查看 vmlinux.lds 中自定义符号的值（截图）。</p></li><li><p>用 <code>csr_read</code> 宏读取 <code>sstatus</code> 寄存器的值，对照 RISC-V 手册解释其含义（截图）。</p></li><li><p>用 <code>csr_write</code> 宏向 <code>sscratch</code> 寄存器写入数据，并验证是否写入成功（截图）。</p></li><li><p>Detail your steps about how to get <code>arch/arm64/kernel/sys.i</code></p></li><li><p>Find system call table of Linux v6.0 for <code>ARM32</code>, <code>RISC-V(32 bit)</code>, <code>RISC-V(64 bit)</code>, <code>x86(32 bit)</code>, <code>x86_64</code><br>List source code file, the whole system call table with macro expanded, screenshot every step.</p></li><li><p>Explain what is ELF file? Try readelf and objdump command on an ELF file, give screenshot of the output.<br>Run an ELF file and cat <code>/proc/PID /maps</code> to give its memory layout.</p></li></ol><p>5, 6, 7 need to have screenshots.</p><h2 id="作业提交"><a href="#作业提交" class="headerlink" title="作业提交"></a>作业提交</h2><p>实验报告需要包含对所有思考题的回答，有截图要求的要截图。</p><p>同学需要提交实验报告以及整个工程代码。在提交前请使用 <code>make clean</code> 清除所有构建产物。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="操作系统" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="os实验文档" scheme="http://example.com/tags/os%E5%AE%9E%E9%AA%8C%E6%96%87%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title>oslab0</title>
    <link href="http://example.com/2023/07/08/oslab0/"/>
    <id>http://example.com/2023/07/08/oslab0/</id>
    <published>2023-07-08T06:42:57.000Z</published>
    <updated>2023-07-29T05:52:30.884Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Lab-0-GDB-QEMU-调试-64-位-RISC-V-LINUX"><a href="#Lab-0-GDB-QEMU-调试-64-位-RISC-V-LINUX" class="headerlink" title="Lab 0: GDB + QEMU 调试 64 位 RISC-V LINUX"></a>Lab 0: GDB + QEMU 调试 64 位 RISC-V LINUX</h1><h2 id="1-实验目的"><a href="#1-实验目的" class="headerlink" title="1 实验目的"></a>1 实验目的</h2><ul><li>了解容器的使用</li><li>使用交叉编译工具, 完成Linux内核代码编译</li><li>使用QEMU运行内核</li><li>熟悉GDB和QEMU联合调试</li></ul><h2 id="2-实验环境"><a href="#2-实验环境" class="headerlink" title="2 实验环境"></a>2 实验环境</h2><ul><li>Docker</li><li>实验环境镜像<a href="https://pan.zju.edu.cn/share/b3cee13d5974178ad441a57c52">下载地址</a></li></ul><h2 id="3-实验基础知识介绍"><a href="#3-实验基础知识介绍" class="headerlink" title="3 实验基础知识介绍"></a>3 实验基础知识介绍</h2><h3 id="3-1-Linux-使用基础"><a href="#3-1-Linux-使用基础" class="headerlink" title="3.1 Linux 使用基础"></a>3.1 Linux 使用基础</h3><p>在 Linux 环境下，人们通常使用命令行接口来完成与计算机的交互。终端（Terminal）是用于处理该过程的一个应用程序，通过终端你可以运行各种程序以及在自己的计算机上处理文件。在类 Unix 的操作系统上，终端可以为你完成一切你所需要的操作。下面我们仅对实验中涉及的一些概念进行介绍，你可以通过下面的链接来对命令行的使用进行学习：</p><ol><li><a href="https://missing-semester-cn.github.io/2020/shell-tools">The Missing Semester of Your CS Education</a><a href="https://www.bilibili.com/video/BV1x7411H7wa?p=2">&gt;&gt;Video&lt;&lt;</a></li><li><a href="https://tldp.org/LDP/GNU-Linux-Tools-Summary/html/index.html">GNU&#x2F;Linux Command-Line Tools Summary</a></li><li><a href="https://github.com/berkeley-scf/tutorial-unix-basics">Basics of UNIX</a></li></ol><h3 id="3-2-Docker-使用基础"><a href="#3-2-Docker-使用基础" class="headerlink" title="3.2 Docker 使用基础"></a>3.2 Docker 使用基础</h3><h4 id="Docker-基本介绍"><a href="#Docker-基本介绍" class="headerlink" title="Docker 基本介绍"></a>Docker 基本介绍</h4><p>Docker 是一种利用容器（container）来进行创建、部署和运行应用的工具。Docker 把一个应用程序运行需要的二进制文件、运行需要的库以及其他依赖文件打包为一个包（package），然后通过该包创建容器并运行，由此被打包的应用便成功运行在了 Docker 容器中。之所以要把应用程序打包，并以容器的方式运行，主要是因为在生产开发环境中，常常会遇到应用程序和系统环境变量以及一些依赖的库文件不匹配，导致应用无法正常运行的问题。Docker 带来的好处是只要我们将应用程序打包完成（组装成为 Docker image），在任意安装了 Docker 的机器上，都可以通过运行容器的方式来运行该应用程序，因而将依赖、环境变量等带来的应用部署问题解决了。</p><p>如果想了解更多 Docker 的详情，请参考<a href="https://www.docker.com/">官网</a>。</p><h4 id="Docker-安装"><a href="#Docker-安装" class="headerlink" title="Docker 安装"></a>Docker 安装</h4><p>请根据 <a href="https://docs.docker.com/get-docker">https://docs.docker.com/get-docker</a> 自行在本机安装 Docker 环境。你可以从 <a href="#2">2 实验环境</a> 中获得实验所需的环境，我们已经为你准备好了 RISC-V 工具链，以及 QEMU 模拟器，使用方法请参见 <a href="#4">4 实验步骤</a>。</p><h3 id="3-3-QEMU-使用基础"><a href="#3-3-QEMU-使用基础" class="headerlink" title="3.3 QEMU 使用基础"></a>3.3 QEMU 使用基础</h3><h4 id="什么是QEMU"><a href="#什么是QEMU" class="headerlink" title="什么是QEMU"></a>什么是QEMU</h4><p>QEMU 是一个功能强大的模拟器，可以在 x86 平台上执行不同架构下的程序。我们实验中采用 QEMU 来完成 RISC-V 架构的程序的模拟。</p><h4 id="如何使用-QEMU（常见参数介绍）"><a href="#如何使用-QEMU（常见参数介绍）" class="headerlink" title="如何使用 QEMU（常见参数介绍）"></a>如何使用 QEMU（常见参数介绍）</h4><p>以以下命令为例，我们简单介绍 QEMU 的参数所代表的含义</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ qemu-system-riscv64 \<br>    -nographic \<br>    -machine virt \<br>    -kernel path/to/linux/arch/riscv/boot/Image \<br>    -device virtio-blk-device,drive=hd0 \<br>    -append <span class="hljs-string">&quot;root=/dev/vda ro console=ttyS0&quot;</span> \<br>    -bios default \<br>    -drive file=rootfs.img,format=raw,<span class="hljs-built_in">id</span>=hd0 \<br>    -S -s<br></code></pre></td></tr></table></figure><ul><li><code>-nographic</code>: 不使用图形窗口，使用命令行</li><li><code>-machine</code>: 指定要 emulate 的机器，可以通过命令 <code>qemu-system-riscv64 -machine help</code> 查看可选择的机器选项</li><li><code>-kernel</code>: 指定内核 image</li><li><code>-append cmdline</code>: 使用cmdline作为内核的命令行</li><li><code>-device</code>: 指定要模拟的设备，可以通过命令 <code>qemu-system-riscv64 -device help</code> 查看可选择的设备，通过命令 <code>qemu-system-riscv64 -device &lt;具体的设备&gt;,help</code> 查看某个设备的命令选项</li><li><code>-drive, file=&lt;file_name&gt;</code>: 使用 <code>file_name</code> 作为文件系统</li><li><code>-S</code>: 启动时暂停CPU执行</li><li><code>-s</code>: -gdb tcp::1234 的简写</li><li><code>-bios default</code>: 使用默认的 OpenSBI firmware 作为 bootloader</li></ul><p>更多参数信息可以参考<a href="https://www.qemu.org/docs/master/system/index.html">这里</a></p><h3 id="3-4-GDB-使用基础"><a href="#3-4-GDB-使用基础" class="headerlink" title="3.4 GDB 使用基础"></a>3.4 GDB 使用基础</h3><h4 id="什么是-GDB"><a href="#什么是-GDB" class="headerlink" title="什么是 GDB"></a>什么是 GDB</h4><p>GNU 调试器（英语：GNU Debugger，缩写：gdb）是一个由 GNU 开源组织发布的、UNIX&#x2F;LINUX 操作系统下的、基于命令行的、功能强大的程序调试工具。借助调试器，我们能够查看另一个程序在执行时实际在做什么（比如访问哪些内存、寄存器），在其他程序崩溃的时候可以比较快速地了解导致程序崩溃的原因。<br>被调试的程序可以是和 gdb 在同一台机器上（本地调试，or native debug），也可以是不同机器上（远程调试， or remote debug）。</p><p>总的来说，gdb 可以有以下4个功能：</p><ul><li>启动程序，并指定可能影响其行为的所有内容</li><li>使程序在指定条件下停止</li><li>检查程序停止时发生了什么</li><li>更改程序中的内容，以便纠正一个bug的影响</li></ul><h4 id="GDB-基本命令介绍"><a href="#GDB-基本命令介绍" class="headerlink" title="GDB 基本命令介绍"></a>GDB 基本命令介绍</h4><ul><li>(gdb) layout asm: 显示汇编代码</li><li>(gdb) start: 单步执行，运行程序，停在第一执行语句</li><li>(gdb) continue: 从断点后继续执行，简写 <code>c</code></li><li>(gdb) next: 单步调试（逐过程，函数直接执行），简写 <code>n</code></li><li>(gdb) step instruction: 执行单条指令，简写 <code>si</code></li><li>(gdb) run: 重新开始运行文件（run-text：加载文本文件，run-bin：加载二进制文件），简写 <code>r</code></li><li>(gdb) backtrace：查看函数的调用的栈帧和层级关系，简写 <code>bt</code></li><li>(gdb) break 设置断点，简写 <code>b</code><ul><li>断在 <code>foo</code> 函数：<code>b foo</code></li><li>断在某地址: <code>b * 0x80200000</code></li></ul></li><li>(gdb) finish: 结束当前函数，返回到函数调用点</li><li>(gdb) frame: 切换函数的栈帧，简写 <code>f</code></li><li>(gdb) print: 打印值及地址，简写 <code>p</code></li><li>(gdb) info：查看函数内部局部变量的数值，简写 <code>i</code><ul><li>查看寄存器 ra 的值：<code>i r ra</code></li></ul></li><li>(gdb) display：追踪查看具体变量值</li><li>(gdb) x&#x2F;4x <addr>: 以 16 进制打印 <addr> 处开始的 16 Bytes 内容</li></ul><p>更多命令可以参考<a href="https://wizardforcel.gitbooks.io/100-gdb-tips/content/">100个gdb小技巧</a></p><h3 id="3-5-Linux-内核编译基础"><a href="#3-5-Linux-内核编译基础" class="headerlink" title="3.5 Linux 内核编译基础"></a>3.5 Linux 内核编译基础</h3><h4 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h4><p>交叉编译指的是在一个平台上编译可以在另一个架构运行的程序。例如在 x86 机器上编译可以在 RISC-V 架构运行的程序，交叉编译需要交叉编译工具链的支持，在我们的实验中所用的交叉编译工具链就是 <code>riscv-gnu-toolchain</code>。</p><h4 id="内核配置"><a href="#内核配置" class="headerlink" title="内核配置"></a>内核配置</h4><p>内核配置是用于配置是否启用内核的各项特性，内核会提供一个名为 <code>defconfig</code> (即default configuration) 的默认配置，该配置文件位于各个架构目录的 <code>configs</code> 文件夹下，例如对于RISC-V而言，其默认配置文件为 <code>arch/riscv/configs/defconfig</code>。使用 <code>make ARCH=riscv defconfig</code> 命令可以在内核根目录下生成一个名为 <code>.config</code> 的文件，包含了内核完整的配置，内核在编译时会根据 <code>.config</code> 进行编译。配置之间存在相互的依赖关系，直接修改defconfig文件或者 <code>.config</code> 有时候并不能达到想要的效果。因此如果需要修改配置一般采用 <code>make ARCH=riscv menuconfig</code> 的方式对内核进行配置。</p><h4 id="常见参数"><a href="#常见参数" class="headerlink" title="常见参数"></a>常见参数</h4><ul><li><code>ARCH</code> 指定架构，可选的值包括arch目录下的文件夹名，如 x86、arm、arm64 等，不同于 arm 和 arm64，32 位和 64 位的RISC-V共用 <code>arch/riscv</code> 目录，通过使用不同的 config 可以编译 32 位或 64 位的内核。</li><li><code>CROSS_COMPILE</code> 指定使用的交叉编译工具链，例如指定 <code>CROSS_COMPILE=riscv64-unknown-linux-gnu-</code>，则编译时会采用 <code>riscv64-unknown-linux-gnu-gcc</code> 作为编译器，编译可以在 RISC-V 64 位平台上运行的 kernel。</li></ul><h4 id="常用的-Linux-下的编译选项"><a href="#常用的-Linux-下的编译选项" class="headerlink" title="常用的 Linux 下的编译选项"></a>常用的 Linux 下的编译选项</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ make <span class="hljs-built_in">help</span>         <span class="hljs-comment"># 查看make命令的各种参数解释</span><br><br>$ make defconfig    <span class="hljs-comment"># 使用当前平台的默认配置，在x86机器上会使用x86的默认配置</span><br>$ make -j$(<span class="hljs-built_in">nproc</span>)   <span class="hljs-comment"># 编译当前平台的内核，-j$(nproc) 为以全部机器硬件线程数进行多线程编译</span><br>$ make -j4          <span class="hljs-comment"># 编译当前平台的内核，-j4 为使用 4 线程进行多线程编译</span><br><br>$ make ARCH=riscv defconfig                                     <span class="hljs-comment"># 使用 RISC-V 平台的默认配置</span><br>$ make ARCH=riscv CROSS_COMPILE=riscv64-linux-gnu- -j$(<span class="hljs-built_in">nproc</span>)   <span class="hljs-comment"># 编译 RISC-V 平台内核</span><br><br>$ make clean        <span class="hljs-comment"># 清除所有编译好的 object 文件</span><br></code></pre></td></tr></table></figure><h2 id="4-实验步骤"><a href="#4-实验步骤" class="headerlink" title="4 实验步骤"></a>4 实验步骤</h2><p><strong>在执行每一条命令前，请你对将要进行的操作进行思考，给出的命令不需要全部执行，并且不是所有的命令都可以无条件执行，请不要直接复制粘贴命令去执行。</strong></p><h3 id="4-1-搭建-Docker-环境"><a href="#4-1-搭建-Docker-环境" class="headerlink" title="4.1 搭建 Docker 环境"></a>4.1 搭建 Docker 环境</h3><p>请根据 <strong>3.2 Docker 使用基础</strong> 安装 Docker 环境。然后<strong>参考并理解</strong>以下步骤，导入我们已经准备好的 Docker 镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 导入docker镜像</span><br>$ docker load &lt; oslab.tar<br><br><span class="hljs-comment"># 查看docker镜像</span><br>$ docker images<br>REPOSITORY       TAG       IMAGE ID       CREATED        SIZE<br>oslab            2021      8c15472cd111   5 months ago   3.63GB<br><br><span class="hljs-comment"># 从镜像创建一个容器</span><br>$ docker run --name oslab -it oslab:2021 bash   <span class="hljs-comment"># --name:容器名称 -i:交互式操作 -t:终端</span><br>root@132a140bd724:/<span class="hljs-comment">#                            # 提示符变为 &#x27;#&#x27; 表明成功进入容器 后面的字符串根据容器而生成，为容器id</span><br>root@132a140bd724:/<span class="hljs-comment"># exit (or CTRL+D)           # 从容器中退出 此时运行docker ps，运行容器的列表为空</span><br><br><span class="hljs-comment"># 启动处于停止状态的容器</span><br>$ docker start oslab        <span class="hljs-comment"># oslab为容器名称</span><br>$ docker ps                 <span class="hljs-comment"># 可看到容器已经启动</span><br>CONTAINER ID   IMAGE          COMMAND         CREATED          STATUS         PORTS                    NAMES<br>234326b4094e   oslab:2021     <span class="hljs-string">&quot;/bin/bash&quot;</span>     5 seconds ago    Up 4 seconds                            compassionate_goldwasser<br><br><span class="hljs-comment"># 从终端连入 docker 容器</span><br>$ docker <span class="hljs-built_in">exec</span> -it oslab bash<br><br><span class="hljs-comment"># 挂载本地目录</span><br><span class="hljs-comment"># 把用户的 home 目录映射到 docker 镜像内的 have-fun-debugging 目录</span><br>$ docker run --name oslab -it -v <span class="hljs-variable">$&#123;HOME&#125;</span>:/have-fun-debugging oslab:2021 bash    <span class="hljs-comment"># -v 本地目录:容器内目录</span><br></code></pre></td></tr></table></figure><h3 id="4-2-获取-Linux-源码和已经编译好的文件系统"><a href="#4-2-获取-Linux-源码和已经编译好的文件系统" class="headerlink" title="4.2 获取 Linux 源码和已经编译好的文件系统"></a>4.2 获取 Linux 源码和已经编译好的文件系统</h3><p>从 <a href="https://www.kernel.org/">https://www.kernel.org</a> 下载最新的 Linux 源码。</p><p>并且使用 git 工具 clone <a href="https://gitee.com/zjusec/os22fall-stu">本仓库</a>。其中已经准备好了根文件系统的镜像。</p><blockquote><p>根文件系统为 Linux Kenrel 提供了基础的文件服务，在启动 Linux Kernel 时是必要的。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">clone</span> https://gitee.com/zjusec/os22fall-stu<br>$ <span class="hljs-built_in">cd</span> os22fall-stu/src/lab0<br>$ <span class="hljs-built_in">ls</span><br>rootfs.img  <span class="hljs-comment"># 已经构建完成的根文件系统的镜像</span><br></code></pre></td></tr></table></figure><h3 id="4-3-编译-linux-内核"><a href="#4-3-编译-linux-内核" class="headerlink" title="4.3 编译 linux 内核"></a>4.3 编译 linux 内核</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">pwd</span><br>path/to/lab0/linux<br>$ make ARCH=riscv CROSS_COMPILE=riscv64-unknown-linux-gnu- defconfig    <span class="hljs-comment"># 生成配置</span><br>$ make ARCH=riscv CROSS_COMPILE=riscv64-unknown-linux-gnu- -j$(<span class="hljs-built_in">nproc</span>)   <span class="hljs-comment"># 编译</span><br></code></pre></td></tr></table></figure><blockquote><p>使用多线程编译一般会耗费大量内存，如果 <code>-j</code> 选项导致内存耗尽 (out of memory)，请尝试调低线程数，比如 <code>-j4</code>, <code>-j8</code> 等。</p></blockquote><h3 id="4-4-使用QEMU运行内核"><a href="#4-4-使用QEMU运行内核" class="headerlink" title="4.4 使用QEMU运行内核"></a>4.4 使用QEMU运行内核</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ qemu-system-riscv64 -nographic -machine virt -kernel path/to/linux/arch/riscv/boot/Image \<br>    -device virtio-blk-device,drive=hd0 -append <span class="hljs-string">&quot;root=/dev/vda ro console=ttyS0&quot;</span> \<br>    -bios default -drive file=rootfs.img,format=raw,<span class="hljs-built_in">id</span>=hd0<br></code></pre></td></tr></table></figure><p>退出 QEMU 的方法为：使用 Ctrl+A，<strong>松开</strong>后再按下 X 键即可退出 QEMU。</p><h3 id="4-5-使用-GDB-对内核进行调试"><a href="#4-5-使用-GDB-对内核进行调试" class="headerlink" title="4.5 使用 GDB 对内核进行调试"></a>4.5 使用 GDB 对内核进行调试</h3><p>这一步需要开启两个 Terminal Session，一个 Terminal 使用 QEMU 启动 Linux，另一个 Terminal 使用 GDB 与 QEMU 远程通信（使用 tcp::1234 端口）进行调试。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Terminal 1</span><br>$ qemu-system-riscv64 -nographic -machine virt -kernel path/to/linux/arch/riscv/boot/Image \<br>    -device virtio-blk-device,drive=hd0 -append <span class="hljs-string">&quot;root=/dev/vda ro console=ttyS0&quot;</span> \<br>    -bios default -drive file=rootfs.img,format=raw,<span class="hljs-built_in">id</span>=hd0 -S -s<br><br><span class="hljs-comment"># Terminal 2</span><br>$ riscv64-unknown-linux-gnu-gdb path/to/linux/vmlinux<br>(gdb) target remote :1234   <span class="hljs-comment"># 连接 qemu</span><br>(gdb) b start_kernel        <span class="hljs-comment"># 设置断点</span><br>(gdb) <span class="hljs-built_in">continue</span>              <span class="hljs-comment"># 继续执行</span><br>(gdb) quit                  <span class="hljs-comment"># 退出 gdb</span><br></code></pre></td></tr></table></figure><h2 id="5-实验任务与要求"><a href="#5-实验任务与要求" class="headerlink" title="5 实验任务与要求"></a>5 实验任务与要求</h2><ul><li>请各位同学独立完成作业，任何抄袭行为都将使本次作业判为0分。</li><li>编译内核并用 GDB + QEMU 调试，在内核初始化过程中设置断点，对内核的启动过程进行跟踪，并尝试使用gdb的各项命令（如 backtrace、finish、frame、info、break、display、next、layout 等）。</li><li>在学在浙大中提交 pdf 格式的实验报告，记录实验过程并截图（4.1-4.4），对每一步的命令以及结果进行必要的解释，记录遇到的问题和心得体会。</li></ul><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><ol><li>使用 <code>riscv64-unknown-elf-gcc</code> 编译单个 <code>.c</code> 文件</li><li>使用 <code>riscv64-unknown-elf-objdump</code> 反汇编 1 中得到的编译产物</li><li>调试 Linux 时:<ol><li>在 GDB 中查看汇编代码</li><li>在 0x80000000 处下断点</li><li>查看所有已下的断点</li><li>在 0x80200000 处下断点</li><li>清除 0x80000000 处的断点</li><li>继续运行直到触发 0x80200000 处的断点</li><li>单步调试一次</li><li>退出 QEMU</li></ol></li><li>使用 <code>make</code> 工具清除 Linux 的构建产物</li><li><code>vmlinux</code> 和 <code>Image</code> 的关系和区别是什么？</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="操作系统" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="os实验文档" scheme="http://example.com/tags/os%E5%AE%9E%E9%AA%8C%E6%96%87%E6%A1%A3/"/>
    
  </entry>
  
  <entry>
    <title>test</title>
    <link href="http://example.com/2023/07/07/test/"/>
    <id>http://example.com/2023/07/07/test/</id>
    <published>2023-07-07T10:59:10.000Z</published>
    <updated>2023-07-29T05:52:30.887Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>This is a test page created by lf601.</p><p>$a^2 &#x3D; 1$</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="测试文档" scheme="http://example.com/categories/%E6%B5%8B%E8%AF%95%E6%96%87%E6%A1%A3/"/>
    
    
    <category term="debug" scheme="http://example.com/tags/debug/"/>
    
  </entry>
  
</feed>
